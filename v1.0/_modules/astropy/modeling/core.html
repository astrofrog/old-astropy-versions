<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.modeling.core &mdash; Astropy v1.0</title>
    
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/badge_only.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.0" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />

<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="../../../_static/copybutton.js"></script>


<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://astropy.readthedocs.org/en/latest/_modules/astropy/modeling/core.html" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "astropy",
    version: "v1.0",
    language: "en",
    page: "_modules/astropy/modeling/core",
    builder: "sphinx",
    theme: "bootstrap-astropy",
    docroot: "/docs/",
    source_suffix: ".rst",
    api_host: "https://readthedocs.org",
    commit: "b14c2e50123aafafd612a79ffb8ad69a0616f52f"
  }
  // Old variables
  var doc_version = "v1.0";
  var doc_slug = "astropy";
  var page_name = "_modules/astropy/modeling/core";
  var html_theme = "bootstrap-astropy";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  // User Analytics Code
  _gaq.push(['user._setAccount', 'UA-30968842-1']);
  _gaq.push(['user._trackPageview']);
  // End User Analytics Code


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->

  </head>
  <body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v1.0</a>
	 &raquo;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for astropy.modeling.core</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines base classes for all models.  The base class of all</span>
<span class="sd">models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is</span>
<span class="sd">the base class for all fittable models. Fittable models can be linear or</span>
<span class="sd">nonlinear in a regression analysis sense.</span>

<span class="sd">All models provide a `__call__` method which performs the transformation in</span>
<span class="sd">a purely mathematical way, i.e. the models are unitless.  Model instances can</span>
<span class="sd">represent either a single model, or a &quot;model set&quot; representing multiple copies</span>
<span class="sd">of the same type of model, but with potentially different values of the</span>
<span class="sd">parameters in each model making up the set.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span>
                        <span class="n">print_function</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">islice</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">indent</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">isinstancemethod</span><span class="p">,</span> <span class="n">metadata</span>
<span class="kn">from</span> <span class="nn">..extern</span> <span class="kn">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">..table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">,</span> <span class="n">sharedmethod</span><span class="p">,</span> <span class="n">find_current_module</span><span class="p">,</span>
                     <span class="n">InheritDocstrings</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..utils.codegen</span> <span class="kn">import</span> <span class="n">make_function_with_signature</span>
<span class="kn">from</span> <span class="nn">..utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">array_repr_oneline</span><span class="p">,</span> <span class="n">check_broadcast</span><span class="p">,</span> <span class="n">combine_labels</span><span class="p">,</span>
                    <span class="n">make_binary_operator_eval</span><span class="p">,</span> <span class="n">ExpressionTree</span><span class="p">,</span>
                    <span class="n">IncompatibleShapeError</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.parameters</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">InputParameterError</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Model&#39;</span><span class="p">,</span> <span class="s">&#39;FittableModel&#39;</span><span class="p">,</span> <span class="s">&#39;Fittable1DModel&#39;</span><span class="p">,</span> <span class="s">&#39;Fittable2DModel&#39;</span><span class="p">,</span>
           <span class="s">&#39;custom_model&#39;</span><span class="p">,</span> <span class="s">&#39;ModelDefinitionError&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="ModelDefinitionError"><a class="viewcode-back" href="../../../api/astropy.modeling.ModelDefinitionError.html#astropy.modeling.ModelDefinitionError">[docs]</a><span class="k">class</span> <span class="nc">ModelDefinitionError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for incorrect models definitions&quot;&quot;&quot;</span>

</div>
<span class="k">def</span> <span class="nf">_model_oper</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a function that evaluates a given Python arithmetic operator</span>
<span class="sd">    between two models.  The operator should be given as a string, like ``&#39;+&#39;``</span>
<span class="sd">    or ``&#39;**&#39;``.</span>

<span class="sd">    Any additional keyword arguments passed in are passed to</span>
<span class="sd">    `_CompoundModelMeta._from_operator`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Note: Originally this used functools.partial, but that won&#39;t work when</span>
    <span class="c"># used in the class definition of _CompoundModelMeta since</span>
    <span class="c"># _CompoundModelMeta has not been defined yet.</span>

    <span class="c"># Perform an arithmetic operation on two models.</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_from_operator</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ModelMeta</span><span class="p">(</span><span class="n">InheritDocstrings</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metaclass for Model.</span>

<span class="sd">    Currently just handles auto-generating the param_names list based on</span>
<span class="sd">    Parameter descriptors declared at the class-level of Model subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">registry</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A registry of all known concrete (non-abstract) Model subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_handle_parameters</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>
        <span class="n">mcls</span><span class="o">.</span><span class="n">_create_inverse_property</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
        <span class="n">mcls</span><span class="o">.</span><span class="n">_handle_backwards_compat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

        <span class="n">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">,</span> <span class="n">mcls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

        <span class="n">mcls</span><span class="o">.</span><span class="n">_handle_special_methods</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">):</span>
            <span class="n">mcls</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom repr for Model subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repr for IPython&#39;s pretty printer.</span>

<span class="sd">        By default IPython &quot;pretty prints&quot; classes, so we need to implement</span>
<span class="sd">        this so that IPython displays the custom repr for Models.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">cls</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this model class--equivalent to ``cls.__name__``.</span>

<span class="sd">        This attribute is provided for symmetry with the `Model.name` attribute</span>
<span class="sd">        of model instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of this model class with a new name.</span>

<span class="sd">        The new class is technically a subclass of the original class, so that</span>
<span class="sd">        instance and type checks will still work.  For example::</span>

<span class="sd">            &gt;&gt;&gt; from astropy.modeling.models import Rotation2D</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation = Rotation2D.rename(&#39;SkyRotation&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SkyRotation</span>
<span class="sd">            &lt;class &#39;__main__.SkyRotation&#39;&gt;</span>
<span class="sd">            Name: SkyRotation (Rotation2D)</span>
<span class="sd">            Inputs: (&#39;x&#39;, &#39;y&#39;)</span>
<span class="sd">            Outputs: (&#39;x&#39;, &#39;y&#39;)</span>
<span class="sd">            Fittable parameters: (&#39;angle&#39;,)</span>
<span class="sd">            &gt;&gt;&gt; issubclass(SkyRotation, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; r = SkyRotation(90)</span>
<span class="sd">            &gt;&gt;&gt; isinstance(r, Rotation2D)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">):</span>
            <span class="c"># Unicode names are not allowed in Python 2, so just convert to</span>
            <span class="c"># ASCII.  As such, for cross-compatibility all model names should</span>
            <span class="c"># just be ASCII for now.</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">)</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="s">&#39;__main__&#39;</span>

        <span class="n">new_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">cls</span><span class="p">,),</span> <span class="p">{})</span>
        <span class="c"># On Python 2 __module__ must be a str, not unicode</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="n">__module__</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;__qualname__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_cls</span><span class="o">.</span><span class="n">__module__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
                <span class="c"># __main__ is not added to a class&#39;s qualified name</span>
                <span class="n">new_cls</span><span class="o">.</span><span class="n">__qualname__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_cls</span><span class="o">.</span><span class="n">__qualname__</span> <span class="o">=</span> <span class="s">&#39;{0}.{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_cls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_parameters</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c"># Handle parameters</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;param_names&#39;</span><span class="p">,</span> <span class="p">())</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">members</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="c"># Name not explicitly given in the constructor; add the name</span>
                <span class="c"># automatically via the attribute name</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">key</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_attr</span> <span class="o">=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">key</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s">&quot;Parameters must be defined with the same name as the &quot;</span>
                    <span class="s">&quot;class attribute they are assigned to.  Parameters may &quot;</span>
                    <span class="s">&quot;take their name from the class attribute automatically &quot;</span>
                    <span class="s">&quot;if the name argument is not given when initializing &quot;</span>
                    <span class="s">&quot;them.&quot;</span><span class="p">)</span>
            <span class="n">parameters</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># If no parameters were defined get out early--this is especially</span>
        <span class="c"># important for PolynomialModels which take a different approach to</span>
        <span class="c"># parameters, since they can have a variable number of them</span>
        <span class="k">if</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="n">mcls</span><span class="o">.</span><span class="n">_check_parameters</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parameters</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_parameters</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="c"># If param_names was declared explicitly we use only the parameters</span>
        <span class="c"># listed manually in param_names, but still check that all listed</span>
        <span class="c"># parameters were declared</span>
        <span class="k">if</span> <span class="n">param_names</span> <span class="ow">and</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">param_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s">&quot;Parameter {0!r} listed in {1}.param_names was not &quot;</span>
                        <span class="s">&quot;declared in the class body.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span>
                                <span class="nb">sorted</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">_order</span><span class="p">))</span>
            <span class="n">members</span><span class="p">[</span><span class="s">&#39;param_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_names</span>
            <span class="n">members</span><span class="p">[</span><span class="s">&#39;_param_orders&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_names</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_inverse_property</span><span class="p">(</span><span class="n">members</span><span class="p">):</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;inverse&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">fget</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">fget</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We allow the @property decorator to be omitted entirely from</span>
            <span class="c"># the class definition, though its use should be encouraged for</span>
            <span class="c"># clarity</span>
            <span class="n">fget</span> <span class="o">=</span> <span class="n">inverse</span>

        <span class="k">def</span> <span class="nf">wrapped_fget</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_inverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_inverse</span>

            <span class="k">return</span> <span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;The ``inverse`` attribute may be assigned a `Model` &quot;</span>
                    <span class="s">&quot;instance or `None` (where `None` restores the default &quot;</span>
                    <span class="s">&quot;inverse for this model if one is defined.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_custom_inverse</span> <span class="o">=</span> <span class="n">value</span>

        <span class="n">members</span><span class="p">[</span><span class="s">&#39;inverse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">wrapped_fget</span><span class="p">,</span> <span class="n">fset</span><span class="p">,</span>
                                      <span class="n">doc</span><span class="o">=</span><span class="n">inverse</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_backwards_compat</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c"># Backwards compatibility check for &#39;eval&#39; -&gt; &#39;evaluate&#39;</span>
        <span class="c"># TODO: Remove sometime after Astropy 1.0 release.</span>
        <span class="k">if</span> <span class="s">&#39;eval&#39;</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="s">&#39;evaluate&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s">&quot;Use of an &#39;eval&#39; method when defining subclasses of &quot;</span>
                <span class="s">&quot;FittableModel is deprecated; please rename this method to &quot;</span>
                <span class="s">&quot;&#39;evaluate&#39;.  Otherwise its semantics remain the same.&quot;</span><span class="p">,</span>
                <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
            <span class="n">members</span><span class="p">[</span><span class="s">&#39;evaluate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="s">&#39;eval&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="s">&#39;evaluate&#39;</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s">&#39;evaluate&#39;</span><span class="p">])</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s">&#39;evaluate&#39;</span><span class="p">],</span> <span class="s">&#39;__isabstractmethod__&#39;</span><span class="p">,</span>
                            <span class="bp">False</span><span class="p">)):</span>
            <span class="c"># Don&#39;t bother making a deprecated eval() except for concrete</span>
            <span class="c"># implementations of evaluate, so that we don&#39;t end up with an eval</span>
            <span class="c"># abstractmethod as well</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;evaluate&#39;</span><span class="p">))</span>
            <span class="n">deprecate</span> <span class="o">=</span> <span class="n">deprecated</span><span class="p">(</span><span class="s">&#39;1.0&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;eval&#39;</span><span class="p">)</span>
            <span class="n">members</span><span class="p">[</span><span class="s">&#39;eval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deprecate</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s">&#39;evaluate&#39;</span><span class="p">])</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_special_methods</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="c"># Handle init creation from inputs</span>
        <span class="k">def</span> <span class="nf">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="c"># Set up the new __call__&#39;s metadata attributes as though it were</span>
            <span class="c"># manually defined in the class definition</span>
            <span class="c"># A bit like functools.update_wrapper but uses the class instead of</span>
            <span class="c"># the wrapped function</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">__module__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__module__</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">__doc__</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;__qualname__&#39;</span><span class="p">):</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="n">__qualname__</span> <span class="o">=</span> <span class="s">&#39;{0}.{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">cls</span><span class="o">.</span><span class="n">__qualname__</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s">&#39;__call__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="s">&#39;inputs&#39;</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="s">&#39;inputs&#39;</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="s">&#39;inputs&#39;</span><span class="p">]</span>
            <span class="c"># Done create a custom __call__ for classes that already have one</span>
            <span class="c"># explicitly defined (this includes the Model base class, and any</span>
            <span class="c"># other classes that manually override __call__</span>
            <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Evaluate this model on the supplied inputs.&quot;&quot;&quot;</span>

                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">inputs</span>
            <span class="n">new_call</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                    <span class="n">__call__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_call</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__call__</span> <span class="o">=</span> <span class="n">new_call</span>

        <span class="k">if</span> <span class="p">(</span><span class="s">&#39;__init__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">parameters</span><span class="p">):</span>
            <span class="c"># If *all* the parameters have default values we can make them</span>
            <span class="c"># keyword arguments; otherwise they must all be positional</span>
            <span class="c"># arguments</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
                   <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">parameters</span><span class="p">)):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;self&#39;</span><span class="p">,)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;self&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">new_init</span> <span class="o">=</span> <span class="n">make_function_with_signature</span><span class="p">(</span>
                    <span class="n">__init__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">varkwargs</span><span class="o">=</span><span class="s">&#39;kwargs&#39;</span><span class="p">)</span>
            <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_init</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__init__</span> <span class="o">=</span> <span class="n">new_init</span>

    <span class="c"># *** Arithmetic operators for creating compound models ***</span>
    <span class="n">__add__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">__sub__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">__mul__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>
    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">__pow__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;**&#39;</span><span class="p">)</span>
    <span class="n">__or__</span> <span class="o">=</span>      <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
    <span class="n">__and__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="c"># The classic __div__ operator need only be implemented for Python 2</span>
        <span class="c"># without from __future__ import division</span>
        <span class="n">__div__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>

    <span class="c"># *** Other utilities ***</span>

    <span class="k">def</span> <span class="nf">_format_cls_repr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># For the sake of familiarity start the output with the standard class</span>
        <span class="c"># __repr__</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">format_inheritance</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">base</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)):</span>
                    <span class="k">break</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;{0} ({1})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39; -&gt; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bases</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">name</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="n">format_inheritance</span><span class="p">(</span><span class="n">cls</span><span class="p">)),</span>
                <span class="p">(</span><span class="s">&#39;Inputs&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;Outputs&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">default_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;Fittable parameters&#39;</span><span class="p">,</span>
                                         <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;{0}: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

            <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c"># If any of the above formatting fails fall back on the basic repr</span>
            <span class="c"># (this is particularly useful in debugging)</span>
            <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="nd">@six.add_metaclass</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">)</span>
<div class="viewcode-block" id="Model"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model">[docs]</a><span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all models.</span>

<span class="sd">    This is an abstract class and should not be instantiated directly.</span>

<span class="sd">    This class sets the constraints and other properties for all individual</span>
<span class="sd">    parameters and performs parameter validation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A human-friendly name associated with this model instance</span>
<span class="sd">        (particularly useful for identifying the individual components of a</span>
<span class="sd">        compound model).</span>

<span class="sd">    fixed : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: bool}`` setting the fixed constraint</span>
<span class="sd">        for one or more parameters.  `True` means the parameter is held fixed</span>
<span class="sd">        during fitting and is prevented from updates once an instance of the</span>
<span class="sd">        model has been created.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.fixed` property of a</span>
<span class="sd">        parameter may be used to lock or unlock individual parameters.</span>

<span class="sd">    tied : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: callable}`` of parameters which are</span>
<span class="sd">        linked to some other parameter. The dictionary values are callables</span>
<span class="sd">        providing the linking relationship.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.tied` property of a</span>
<span class="sd">        parameter may be used to set the ``tied`` constraint on individual</span>
<span class="sd">        parameters.</span>

<span class="sd">    bounds : dict, optional</span>
<span class="sd">        Dictionary ``{parameter_name: value}`` of lower and upper bounds of</span>
<span class="sd">        parameters. Keys are parameter names. Values are a list of length 2</span>
<span class="sd">        giving the desired range for the parameter.</span>

<span class="sd">        Alternatively the `~astropy.modeling.Parameter.min` and</span>
<span class="sd">        `~astropy.modeling.Parameter.max` or</span>
<span class="sd">        ~astropy.modeling.Parameter.bounds` properties of a parameter may be</span>
<span class="sd">        used to set bounds on individual parameters.</span>

<span class="sd">    eqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``eqcons[j](x0, *args) == 0.0``</span>
<span class="sd">        in a successfully optimized problem.</span>

<span class="sd">    ineqcons : list, optional</span>
<span class="sd">        List of functions of length n such that ``ieqcons[j](x0, *args) &gt;=</span>
<span class="sd">        0.0`` is a successfully optimized problem.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.modeling import models</span>
<span class="sd">    &gt;&gt;&gt; def tie_center(model):</span>
<span class="sd">    ...         mean = 50 * model.stddev</span>
<span class="sd">    ...         return mean</span>
<span class="sd">    &gt;&gt;&gt; tied_parameters = {&#39;mean&#39;: tie_center}</span>

<span class="sd">    Specify that ``&#39;mean&#39;`` is a tied parameter in one of two ways:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        tied=tied_parameters)</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied = tie_center</span>
<span class="sd">    &gt;&gt;&gt; g1.mean.tied</span>
<span class="sd">    &lt;function tie_center at 0x...&gt;</span>

<span class="sd">    Fixed parameters:</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,</span>
<span class="sd">    ...                        fixed={&#39;stddev&#39;: True})</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed = True</span>
<span class="sd">    &gt;&gt;&gt; g1.stddev.fixed</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_constraints</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;fixed&#39;</span><span class="p">,</span> <span class="s">&#39;tied&#39;</span><span class="p">,</span> <span class="s">&#39;bounds&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that can be set on a model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model_constraints</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;eqcons&#39;</span><span class="p">,</span> <span class="s">&#39;ineqcons&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily for informational purposes, these are the types of constraints</span>
<span class="sd">    that constrain model evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">param_names</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Names of the parameters that describe models of this type.</span>

<span class="sd">    The parameters in this tuple are in the same order they should be passed in</span>
<span class="sd">    when initializing a model of a specific type.  Some types of models, such</span>
<span class="sd">    as polynomial models, have a different number of parameters depending on</span>
<span class="sd">    some other property of the model, such as the degree.</span>

<span class="sd">    When defining a custom model class the value of this attribute is</span>
<span class="sd">    automatically set by the `~astropy.modeling.Parameter` attributes defined</span>
<span class="sd">    in the class body.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;The name(s) of the input variable(s) on which a model is evaluated.&quot;&quot;&quot;</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;The name(s) of the output(s) of the model.&quot;&quot;&quot;</span>

    <span class="n">standard_broadcasting</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">MetaData</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;A dict-like object to store optional information.&quot;&quot;&quot;</span>

    <span class="c"># By default models either use their own inverse property or have no</span>
    <span class="c"># inverse at all, but users my also assign a custom inverse to a model,</span>
    <span class="c"># optionally; in that case it is of course up to the user to determine</span>
    <span class="c"># whether their inverse is *actually* an inverse to the model they assign</span>
    <span class="c"># it to.</span>
    <span class="n">_custom_inverse</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># Default n_models attribute, so that __len__ is still defined even when a</span>
    <span class="c"># model hasn&#39;t completed initialization yet</span>
    <span class="n">_n_models</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;meta&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_constraints</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># Remaining keyword args are either parameter values or invalid</span>
        <span class="c"># Parameter values must be passed in as keyword arguments in order to</span>
        <span class="c"># distinguish them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_repr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span>

<div class="viewcode-block" id="Model.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this model using the given input(s) and the parameter values</span>
<span class="sd">        that were specified when the model was instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inputs</span><span class="p">,</span> <span class="n">format_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inputs</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">(</span><span class="n">raw</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_outputs</span><span class="p">(</span><span class="n">format_info</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c"># *** Arithmetic operators for creating compound models ***</span></div>
    <span class="n">__add__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">__sub__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">__mul__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">)</span>
    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">__pow__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;**&#39;</span><span class="p">)</span>
    <span class="n">__or__</span> <span class="o">=</span>      <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)</span>
    <span class="n">__and__</span> <span class="o">=</span>     <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">__div__</span> <span class="o">=</span> <span class="n">_model_oper</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>

    <span class="c"># *** Properties ***</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User-provided name for this model instance.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.4&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;len(model)&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">param_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of inputs to this model.</span>

<span class="sd">        Equivalent to ``len(model.inputs)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of outputs from this model.</span>

<span class="sd">        Equivalent to ``len(model.outputs)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of the model set axis--that is the axis of a parameter array</span>
<span class="sd">        that pertains to which model a parameter value pertains to--as</span>
<span class="sd">        specified when the model was initialized.</span>

<span class="sd">        See the documentation on `Model Sets</span>
<span class="sd">        &lt;http://docs.astropy.org/en/stable/modeling/models.html#model-sets&gt;`_</span>
<span class="sd">        for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parameters as a pset.</span>

<span class="sd">        This is a list with one item per parameter set, which is an array of</span>
<span class="sd">        that parameter&#39;s values across all parameter sets, with the last axis</span>
<span class="sd">        associated with the parameter set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_sets</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flattened array of all parameter values in all parameter sets.</span>

<span class="sd">        Fittable parameters maintain this list and fitters modify it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Currently the sequence of a model&#39;s parameters must be contiguous</span>
        <span class="c"># within the _parameters array (which may be a view of a larger array,</span>
        <span class="c"># for example when taking a sub-expression of a compound model), so</span>
        <span class="c"># the assumption here is reliable:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="c"># Trivial, but not unheard of</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>

    <span class="nd">@parameters.setter</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigning to this attribute updates the parameters array rather than</span>
<span class="sd">        replacing it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;slice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s">&quot;Input parameter values not compatible with the model &quot;</span>
                <span class="s">&quot;parameters array: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `dict` mapping parameter names to their fixed constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s">&#39;fixed&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `dict` mapping parameter names to their tied constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s">&#39;tied&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `dict` mapping parameter names to their upper and lower bounds as</span>
<span class="sd">        ``(min, max)`` tuples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s">&#39;bounds&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter equality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s">&#39;eqcons&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ineqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of parameter inequality constraints.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="s">&#39;ineqcons&#39;</span><span class="p">]</span>

    <span class="c"># *** Public methods ***</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `Model` instance which performs the inverse</span>
<span class="sd">        transform, if an analytic inverse is defined for this model.</span>

<span class="sd">        Even on models that don&#39;t have an inverse defined, this property can be</span>
<span class="sd">        set with a manually-defined inverse, such a pre-computed or</span>
<span class="sd">        experimentally determined inverse (often given as a</span>
<span class="sd">        `~astropy.modeling.polynomial.PolynomialModel`, but not by</span>
<span class="sd">        requirement).</span>

<span class="sd">        Note to authors of `Model` subclasses:  To define an inverse for a</span>
<span class="sd">        model simply override this property to return the appropriate model</span>
<span class="sd">        representing the inverse.  The machinery that will make the inverse</span>
<span class="sd">        manually-overridable is added automatically by the base class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;An analytical inverse transform has not &quot;</span>
                                  <span class="s">&quot;been implemented for this model.&quot;</span><span class="p">)</span>

    <span class="nd">@abc.abstractmethod</span>
<div class="viewcode-block" id="Model.evaluate"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the model on some input variables.&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="Model.prepare_inputs"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.prepare_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used in `~astropy.modeling.Model.__call__` to ensure</span>
<span class="sd">        that all the inputs to the model can be broadcast into compatible</span>
<span class="sd">        shapes (if one or both of them are input as arrays), particularly if</span>
<span class="sd">        there are more than one parameter sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># By default the model_set_axis for the input is assumed to be the</span>
            <span class="c"># same as that for the parameters the model was defined with</span>
            <span class="c"># TODO: Ensure that negative model_set_axis arguments are respected</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_set_axis</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">_input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="n">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span>
                               <span class="n">model_set_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">)</span>

        <span class="c"># The input formatting required for single models versus a multiple</span>
        <span class="c"># model set are different enough that they&#39;ve been split into separate</span>
        <span class="c"># subroutines</span>
        <span class="k">if</span> <span class="n">n_models</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_inputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_inputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span>
                                             <span class="n">model_set_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Model.prepare_outputs"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.prepare_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_info</span><span class="p">,</span> <span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_outputs_single_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_prepare_outputs_model_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">)</span>
</div>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;1.0&#39;</span><span class="p">,</span>
                <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;Use Model operators (TODO: link to compound &#39;</span>
                            <span class="s">&#39;model docs&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Model.add_model"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.add_model">[docs]</a>    <span class="k">def</span> <span class="nf">add_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a CompositeModel by chaining the current model with the new one</span>
<span class="sd">        using the specified mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : an instance of a subclass of Model</span>
<span class="sd">        mode :  string</span>
<span class="sd">               &#39;parallel&#39;, &#39;serial&#39;, &#39;p&#39; or &#39;s&#39;</span>
<span class="sd">               a flag indicating whether to combine the models</span>
<span class="sd">               in series or in parallel</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : CompositeModel</span>
<span class="sd">            an instance of CompositeModel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">._compound_deprecated</span> <span class="kn">import</span> <span class="p">(</span><span class="n">SummedCompositeModel</span><span class="p">,</span>
                                           <span class="n">SerialCompositeModel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;parallel&#39;</span><span class="p">,</span> <span class="s">&#39;p&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">SummedCompositeModel</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;serial&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">SerialCompositeModel</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span><span class="s">&quot;Unrecognized mode {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Model.copy"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model.</span>

<span class="sd">        Uses a deep copy so that all model attributes, including parameter</span>
<span class="sd">        values, are copied as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="nd">@sharedmethod</span>
<div class="viewcode-block" id="Model.rename"><a class="viewcode-back" href="../../../api/astropy.modeling.Model.html#astropy.modeling.Model.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this model with a new name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">new_model</span>

    <span class="c"># *** Internal methods ***</span></div>
    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">_from_existing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">existing</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new instance of ``cls`` that shares its underlying parameter</span>
<span class="sd">        values with an existing model instance given by ``existing``.</span>

<span class="sd">        This is used primarily by compound models to return a view of an</span>
<span class="sd">        individual component of a compound model.  ``param_names`` should be</span>
<span class="sd">        the names of the parameters in the *existing* model to use as the</span>
<span class="sd">        parameters in this new model.  Its length should equal the number of</span>
<span class="sd">        parameters this model takes, so that it can map parameters on the</span>
<span class="sd">        existing model to parameters on this model one-to-one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Basically this is an alternative __init__</span>
        <span class="c"># TODO: Support constraints properly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="c"># self is a class, not an instance</span>
            <span class="n">needs_initialization</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">dummy_args</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">dummy_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">needs_initialization</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_constraints</span><span class="p">({})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_n_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_model_set_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param_a</span><span class="p">,</span> <span class="n">param_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
            <span class="c"># Take the param metrics info for the giving parameters in the</span>
            <span class="c"># existing model, and hand them to the appropriate parameters in</span>
            <span class="c"># the new model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">param_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">param_b</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">needs_initialization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">dummy_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_initialize_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop parameter constraint values off the keyword arguments passed to</span>
<span class="sd">        `Model.__init__` and store them in private instance attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_constraints&#39;</span><span class="p">):</span>
            <span class="c"># Skip constraint initialization if it has already been handled via</span>
            <span class="c"># an alternate initialization</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># Pop any constraints off the keyword arguments</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

            <span class="c"># Update with default parameter constraints</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>

                <span class="c"># Parameters don&#39;t have all constraint types</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_constraints</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_initialize_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the _parameters array that stores raw parameter values for</span>
<span class="sd">        all parameter sets for use with vectorized fitting algorithms; on</span>
<span class="sd">        FittableModels the _param_name attributes actually just reference</span>
<span class="sd">        slices of this array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_parameters&#39;</span><span class="p">):</span>
            <span class="c"># Skip parameter initialization if it has already been handled via</span>
            <span class="c"># an alternate initialization</span>
            <span class="k">return</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Pop off param_dim and handle backwards compatibility</span>
        <span class="k">if</span> <span class="s">&#39;param_dim&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">n_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;param_dim&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s">&#39;The param_dim argument to {0}.__init__ is deprecated; &#39;</span>
                <span class="s">&#39;use n_models instead.  See also the model_set_axis argument &#39;</span>
                <span class="s">&#39;and related discussion in the docstring for Model.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;n_models&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&quot;param_dim and n_models cannot both be specified; use &quot;</span>
                    <span class="s">&quot;n_models, as param_dim is deprecated&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;n_models&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n_models</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_models</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&quot;n_models must be either None (in which case it is &quot;</span>
                <span class="s">&quot;determined from the model_set_axis of the parameter initial &quot;</span>
                <span class="s">&quot;values) or it must be a positive integer &quot;</span>
                <span class="s">&quot;(got {0!r})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_models</span><span class="p">))</span>

        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;model_set_axis&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Default to zero</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Otherwise disable</span>
                <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">model_set_axis</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;model_set_axis must be either False or an integer &quot;</span>
                    <span class="s">&quot;specifying the parameter array axis to map to each &quot;</span>
                    <span class="s">&quot;model in a set of models (got {0!r}).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">model_set_axis</span><span class="p">))</span>

        <span class="c"># Process positional arguments by matching them up with the</span>
        <span class="c"># corresponding parameters in self.param_names--if any also appear as</span>
        <span class="c"># keyword arguments this presents a conflict</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&quot;{0}.__init__() takes at most {1} positional arguments ({2} &quot;</span>
                <span class="s">&quot;given)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># A value of None implies using the default value, if exists</span>
                <span class="k">continue</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c"># At this point the only remaining keyword arguments should be</span>
        <span class="c"># parameter names; any others are in error.</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s">&quot;{0}.__init__() got multiple values for parameter &quot;</span>
                        <span class="s">&quot;{1!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">param_name</span><span class="p">))</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c"># If any keyword arguments were left over at this point they are</span>
            <span class="c"># invalid--the base class should only be passed the parameter</span>
            <span class="c"># values, constraints, and param_dim</span>
            <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c"># Just raise an error on the first unrecognized argument</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&#39;{0}.__init__() got an unrecognized parameter &#39;</span>
                    <span class="s">&#39;{1!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span> <span class="o">=</span> <span class="n">model_set_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c"># Determine the number of model sets: If the model_set_axis is</span>
        <span class="c"># None then there is just one parameter set; otherwise it is determined</span>
        <span class="c"># by the size of that axis on the first parameter--if the other</span>
        <span class="c"># parameters don&#39;t have the right number of axes or the sizes of their</span>
        <span class="c"># model_set_axis don&#39;t match an error is raised</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">n_models</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_ndim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">model_set_axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_ndim</span> <span class="o">=</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">param_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">min_ndim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s">&quot;All parameter values must be arrays of dimension &quot;</span>
                        <span class="s">&quot;at least {0} for model_set_axis={1} (the value &quot;</span>
                        <span class="s">&quot;given for {2!r} is only {3}-dimensional)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">min_ndim</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">))</span>

                <span class="n">max_ndim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_ndim</span><span class="p">,</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># Use the dimensions of the first parameter to determine</span>
                    <span class="c"># the number of model sets</span>
                    <span class="n">n_models</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                        <span class="s">&quot;Inconsistent dimensions for parameter {0!r} for &quot;</span>
                        <span class="s">&quot;{1} model sets.  The length of axis {2} must be the &quot;</span>
                        <span class="s">&quot;same for all input parameter values&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">max_ndim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_models</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">n_models</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_broadcast</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_models</span> <span class="o">=</span> <span class="n">n_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_parameter_values</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_parameter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="c"># self._param_metrics should have been initialized in</span>
        <span class="c"># self._initialize_parameters</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">default</span>

                <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># No value was supplied for the parameter, and the</span>
                    <span class="c"># parameter does not have a default--therefor the model is</span>
                    <span class="c"># underspecified</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s">&quot;{0}.__init__() requires a value for parameter &quot;</span>
                        <span class="s">&quot;{1!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

                <span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

            <span class="n">param_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">param_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">param_size</span><span class="p">)</span>

            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;slice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_slice</span>
            <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_shape</span>
            <span class="n">total_size</span> <span class="o">+=</span> <span class="n">param_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span> <span class="o">=</span> <span class="n">param_metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c"># Now set the parameter values (this will also fill</span>
        <span class="c"># self._parameters)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_param_broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">max_ndim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This subroutine checks that all parameter arrays can be broadcast</span>
<span class="sd">        against each other, and determines the shapes parameters must have in</span>
<span class="sd">        order to broadcast correctly.</span>

<span class="sd">        If model_set_axis is None this merely checks that the parameters</span>
<span class="sd">        broadcast and returns an empty dict if so.  This mode is only used for</span>
<span class="sd">        single model sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_set_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_set_axis</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="c"># Previously this just used iteritems(params), but we loop over all</span>
            <span class="c"># param_names instead just to ensure some determinism in the</span>
            <span class="c"># ordering behavior</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c"># We&#39;ve already checked that each parameter array is compatible in</span>
            <span class="c"># the model_set_axis dimension, but now we need to check the</span>
            <span class="c"># dimensions excluding that axis</span>
            <span class="c"># Split the array dimensions into the axes before model_set_axis</span>
            <span class="c"># and after model_set_axis</span>
            <span class="n">param_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">param_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_ndim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">param_ndim</span> <span class="o">&lt;</span> <span class="n">max_ndim</span><span class="p">:</span>
                <span class="c"># All arrays have the same number of dimensions up to the</span>
                <span class="c"># model_set_axis dimension, but after that they may have a</span>
                <span class="c"># different number of trailing axes.  The number of trailing</span>
                <span class="c"># axes must be extended for mutual compatibility.  For example</span>
                <span class="c"># if max_ndim = 3 and model_set_axis = 0, an array with the</span>
                <span class="c"># shape (2, 2) must be extended to (2, 1, 2).  However, an</span>
                <span class="c"># array with shape (2,) is extended to (2, 1).</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_ndim</span> <span class="o">-</span> <span class="n">param_ndim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># Just need to prepend axes to make up the difference</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">param_shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">param_shape</span><span class="p">[:</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">new_axes</span> <span class="o">+</span>
                                       <span class="n">param_shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;broadcast_shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast_shape</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>

        <span class="c"># Now check mutual broadcastability of all shapes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">IncompatibleShapeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">shape_a</span><span class="p">,</span> <span class="n">shape_a_idx</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">,</span> <span class="n">shape_b_idx</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
            <span class="n">param_a</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="n">shape_a_idx</span><span class="p">]</span>
            <span class="n">param_b</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="n">shape_b_idx</span><span class="p">]</span>

            <span class="k">raise</span> <span class="n">InputParameterError</span><span class="p">(</span>
                <span class="s">&quot;Parameter {0!r} of shape {1!r} cannot be broadcast with &quot;</span>
                <span class="s">&quot;parameter {2!r} of shape {3!r}.  All parameter arrays &quot;</span>
                <span class="s">&quot;must have shapes that are mutually compatible according &quot;</span>
                <span class="s">&quot;to the broadcasting rules.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_a</span><span class="p">,</span> <span class="n">shape_a</span><span class="p">,</span>
                                                    <span class="n">param_b</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_param_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the Model.param_sets property.</span>

<span class="sd">        This internal implementation has a ``raw`` argument which controls</span>
<span class="sd">        whether or not to return the raw parameter values (i.e. the values that</span>
<span class="sd">        are actually stored in the ._parameters array, as opposed to the values</span>
<span class="sd">        displayed to users.  In most cases these are one in the same but there</span>
<span class="sd">        are currently a few exceptions.</span>

<span class="sd">        Note: This is notably an overcomplicated device and may be removed</span>
<span class="sd">        entirely in the near future.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_metrics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">raw</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">_raw_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;broadcast_shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Add a single param set axis to the parameter&#39;s value (thus</span>
            <span class="c"># converting scalars to shape (1,) array values) for consistency</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span><span class="p">])</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># If the parameters are not all the same shape, converting to an</span>
            <span class="c"># array is going to produce an object array</span>
            <span class="c"># However the way Numpy creates object arrays is tricky in that it</span>
            <span class="c"># will recurse into array objects in the list and break them up</span>
            <span class="c"># into separate objects.  Doing things this way ensures a 1-D</span>
            <span class="c"># object array the elements of which are the individual parameter</span>
            <span class="c"># arrays.  There&#39;s not much reason to do this over returning a list</span>
            <span class="c"># except for consistency</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">psets</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">return</span> <span class="n">psets</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__repr__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__repr__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: I think this could be reworked to preset model sets better</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="s">&quot;{0}={1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                             <span class="n">array_repr_oneline</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;name={0!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">defaults</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;{0}={1!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwarg</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;n_models={0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s">&#39;&lt;{0}({1})&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal implementation of ``__str__``.</span>

<span class="sd">        This is separated out for ease of use by subclasses that wish to</span>
<span class="sd">        override the default ``__str__`` while keeping the same basic</span>
<span class="sd">        formatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">default_keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;Model&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Inputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Outputs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Model set size&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;{0}: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_keywords</span> <span class="o">+</span> <span class="n">keywords</span>
                 <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;Parameters:&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                       <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>

        <span class="n">param_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">param_table</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="FittableModel"><a class="viewcode-back" href="../../../api/astropy.modeling.FittableModel.html#astropy.modeling.FittableModel">[docs]</a><span class="k">class</span> <span class="nc">FittableModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for models that can be fitted using the built-in fitting</span>
<span class="sd">    algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">linear</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="c"># derivative with respect to parameters</span>
    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function (similar to the model&#39;s `~Model.evaluate`) to compute the</span>
<span class="sd">    derivatives of the model with respect to its parameters, for use by fitting</span>
<span class="sd">    algorithms.  In other words, this computes the Jacobian matrix with respect</span>
<span class="sd">    to the model&#39;s parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Flag that indicates if the model derivatives with respect to parameters</span>
    <span class="c"># are given in columns or rows</span>
    <span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">fittable</span> <span class="o">=</span> <span class="bp">True</span>

</div>
<div class="viewcode-block" id="Fittable1DModel"><a class="viewcode-back" href="../../../api/astropy.modeling.Fittable1DModel.html#astropy.modeling.Fittable1DModel">[docs]</a><span class="k">class</span> <span class="nc">Fittable1DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for one-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,)</span>

</div>
<div class="viewcode-block" id="Fittable2DModel"><a class="viewcode-back" href="../../../api/astropy.modeling.Fittable2DModel.html#astropy.modeling.Fittable2DModel">[docs]</a><span class="k">class</span> <span class="nc">Fittable2DModel</span><span class="p">(</span><span class="n">FittableModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for two-dimensional fittable models.</span>

<span class="sd">    This class provides an easier interface to defining new models.</span>
<span class="sd">    Examples can be found in `astropy.modeling.functional_models`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">,)</span>

</div>
<span class="k">def</span> <span class="nf">_make_arithmetic_operator</span><span class="p">(</span><span class="n">oper</span><span class="p">):</span>
    <span class="c"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c"># documentation purposes:</span>
    <span class="c">#</span>
    <span class="c">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c">#</span>
    <span class="c"># and similarly for g</span>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">make_binary_operator_eval</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">op</span>


<span class="k">def</span> <span class="nf">_composition_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c"># documentation purposes:</span>
    <span class="c">#</span>
    <span class="c">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c">#</span>
    <span class="c"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">),</span> <span class="n">params</span><span class="p">),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_join_operator</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="c"># We don&#39;t bother with tuple unpacking here for efficiency&#39;s sake, but for</span>
    <span class="c"># documentation purposes:</span>
    <span class="c">#</span>
    <span class="c">#     f_eval, f_n_inputs, f_n_outputs = f</span>
    <span class="c">#</span>
    <span class="c"># and similarly for g</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[:</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span>
                                    <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">inputs</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]:],</span> <span class="n">params</span><span class="p">)),</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="c"># TODO: Support a couple unary operators--at least negation?</span>
<span class="n">BINARY_OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;+&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">),</span>
    <span class="s">&#39;-&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">),</span>
    <span class="s">&#39;*&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">),</span>
    <span class="s">&#39;/&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">),</span>
    <span class="s">&#39;**&#39;</span><span class="p">:</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">),</span>
    <span class="s">&#39;|&#39;</span><span class="p">:</span> <span class="n">_composition_operator</span><span class="p">,</span>
    <span class="s">&#39;&amp;&#39;</span><span class="p">:</span> <span class="n">_join_operator</span>
<span class="p">}</span>


<span class="n">_ORDER_OF_OPERATORS</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;|&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s">&#39;&amp;&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;**&#39;</span><span class="p">,)]</span>
<span class="n">OPERATOR_PRECEDENCE</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_ORDER_OF_OPERATORS</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
        <span class="n">OPERATOR_PRECEDENCE</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
<span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">ops</span>


<span class="k">class</span> <span class="nc">_CompoundModelMeta</span><span class="p">(</span><span class="n">_ModelMeta</span><span class="p">):</span>
    <span class="n">_tree</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_submodels</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_submodel_names</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_nextid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">_param_names</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c"># _param_map is a mapping of the compound model&#39;s generated param names to</span>
    <span class="c"># the parameters of submodels they are associated with.  The values in this</span>
    <span class="c"># mapping are (idx, name) tuples were idx is the index of the submodel this</span>
    <span class="c"># parameter is associated with, and name is the same parameter&#39;s name on</span>
    <span class="c"># the submodel</span>
    <span class="c"># In principle this will allow compound models to give entirely new names</span>
    <span class="c"># to parameters that don&#39;t have to be the same as their original names on</span>
    <span class="c"># the submodels, but right now that isn&#39;t taken advantage of</span>
    <span class="n">_param_map</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">_slice_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c"># When taking slices of a compound model, this keeps track of how offset</span>
    <span class="c"># the first model in the slice is from the first model in the original</span>
    <span class="c"># compound model it was taken from</span>

    <span class="c"># This just inverts _param_map, swapping keys with values.  This is also</span>
    <span class="c"># useful to have.</span>
    <span class="n">_param_map_inverse</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_fittable</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">_evaluate</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c"># Make sure the _tree attribute is set; otherwise we are not looking up</span>
        <span class="c"># an attribute on a concrete compound model class and should just raise</span>
        <span class="c"># the AttributeError</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_init_param_descriptors</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># This case is mostly for debugging purposes</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">()</span>

        <span class="n">expression</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_format_expression</span><span class="p">()</span>
        <span class="n">components</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;[{0}]: {1!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()))</span>
        <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;Expression&#39;</span><span class="p">,</span> <span class="n">expression</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;Components&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="n">indent</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_format_cls_repr</span><span class="p">(</span><span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of attributes defined on a compound model, including</span>
<span class="sd">        all of its parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># The *args is to address a bug (?) on Python 2.6 where the dir()</span>
        <span class="c"># builtin calls __dir__ with an additional (unused) argument</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Annoyingly, this will only work for Python 3.3+</span>
            <span class="n">basedir</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__dir__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">basedir</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">((</span><span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cls</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__dict__</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="n">basedir</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="n">basedir</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">basedir</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">submodel_names</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_submodel_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_submodel_names</span>

        <span class="n">by_name</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">submodel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()):</span>
            <span class="c"># Keep track of the original sort order of the submodels</span>
            <span class="n">by_name</span><span class="p">[</span><span class="n">submodel</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">basename</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">by_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># There is only one model with this name, so it doesn&#39;t need an</span>
                <span class="c"># index appended to its name</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">basename</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;{0}_{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">idx</span><span class="p">))</span>

        <span class="c"># Sort according to the models&#39; original sort orders</span>
        <span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">_submodels_names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_init_param_names</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_param_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fittable</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_fittable</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_fittable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">fittable</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_fittable</span>

    <span class="c"># TODO: Maybe we could use make_function_with_signature for evaluate, but</span>
    <span class="c"># it&#39;s probably not worth it (and I&#39;m not sure what the limit is on number</span>
    <span class="c"># of function arguments/local variables but we could break that limit for</span>
    <span class="c"># complicated compound models...</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_evaluate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">BINARY_OPERATORS</span><span class="p">,</span>
                                      <span class="n">getter</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">_model_evaluate_getter</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Making this a staticmethod isn&#39;t strictly necessary for Python 3,</span>
            <span class="c"># but it is necessary on Python 2 since looking up cls._evaluate</span>
            <span class="c"># will return an unbound method otherwise</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_evaluate</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="c"># TODO: This supports creating a new compound model from two existing</span>
    <span class="c"># compound models (or normal models) and a single operator.  However, it</span>
    <span class="c"># ought also to be possible to create a new model from an *entire*</span>
    <span class="c"># expression, represented as a sequence of operators and their operands (or</span>
    <span class="c"># an exiting ExpressionTree) and build that into a compound model without</span>
    <span class="c"># creating an intermediate _CompoundModel class for every single operator</span>
    <span class="c"># in the expression.  This will prove to be a useful optimization in many</span>
    <span class="c"># cases</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_operator</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">additional_members</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Python operator (represented by a string, such as ``&#39;+&#39;``</span>
<span class="sd">        or ``&#39;*&#39;``, and two model classes or instances, return a new compound</span>
<span class="sd">        model that evaluates the given operator on the outputs of the left and</span>
<span class="sd">        right input models.</span>

<span class="sd">        If either of the input models are a model *class* (i.e. a subclass of</span>
<span class="sd">        `~astropy.modeling.Model`) then the returned model is a new subclass of</span>
<span class="sd">        `~astropy.modeling.Model` that may be instantiated with any parameter</span>
<span class="sd">        values.  If both input models are *instances* of a model, a new class</span>
<span class="sd">        is still created, but this method returns an *instance* of that class,</span>
<span class="sd">        taking the parameter values from the parameters of the input model</span>
<span class="sd">        instances.</span>

<span class="sd">        If given, the ``additional_members`` `dict` may provide additional</span>
<span class="sd">        class members that should be added to the generated</span>
<span class="sd">        `~astropy.modeling.Model` subclass.  Some members that are generated by</span>
<span class="sd">        this method should not be provided by ``additional_members``.  These</span>
<span class="sd">        include ``_tree``, ``inputs``, ``outputs``, ``linear``,</span>
<span class="sd">        ``standard_broadcasting``, and ``__module__`.  This is currently for</span>
<span class="sd">        internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Note, currently this only supports binary operators, but could be</span>
        <span class="c"># easily extended to support unary operators (namely &#39;-&#39;) if/when</span>
        <span class="c"># needed</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="p">,</span> <span class="n">_CompoundModel</span><span class="p">)):</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_tree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExpressionTree</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="n">ExpressionTree</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s">&#39;CompoundModel{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_nextid</span><span class="p">))</span>
        <span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_nextid</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="s">&#39;__main__&#39;</span>

        <span class="c"># TODO: These aren&#39;t the full rules for handling inputs and outputs, but</span>
        <span class="c"># this will handle most basic cases correctly</span>
        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span>

            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s">&quot;Unsupported operands for |: {0} (n_inputs={1}, &quot;</span>
                    <span class="s">&quot;n_outputs={2}) and {3} (n_inputs={4}, n_outputs={5}); &quot;</span>
                    <span class="s">&quot;n_outputs for the left-hand model must match n_inputs &quot;</span>
                    <span class="s">&quot;for the right-hand model.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">combine_labels</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Without loss of generality</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">outputs</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span> <span class="ow">or</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
                    <span class="s">&quot;Unsupported operands for {0}: {1} (n_inputs={2}, &quot;</span>
                    <span class="s">&quot;n_outputs={3}) and {4} (n_inputs={5}, n_outputs={6}); &quot;</span>
                    <span class="s">&quot;models must have the same n_inputs and the same &quot;</span>
                    <span class="s">&quot;n_outputs for this operator&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">,</span> <span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">):</span>
            <span class="n">linear</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">linear</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Which is not to say it is *definitely* not linear but it would be</span>
            <span class="c"># trickier to determine</span>
            <span class="n">linear</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">standard_broadcasting</span> <span class="o">=</span> \
                <span class="n">left</span><span class="o">.</span><span class="n">standard_broadcasting</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">standard_broadcasting</span>

        <span class="c"># Note: If any other members are added here, make sure to mention them</span>
        <span class="c"># in the docstring of this method.</span>
        <span class="n">members</span> <span class="o">=</span> <span class="n">additional_members</span>
        <span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s">&#39;_tree&#39;</span><span class="p">:</span> <span class="n">tree</span><span class="p">,</span>
            <span class="c"># TODO: These are temporary until we implement the full rules</span>
            <span class="c"># for handling inputs/outputs</span>
            <span class="s">&#39;inputs&#39;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">,</span>
            <span class="s">&#39;outputs&#39;</span><span class="p">:</span> <span class="n">outputs</span><span class="p">,</span>
            <span class="s">&#39;linear&#39;</span><span class="p">:</span> <span class="n">linear</span><span class="p">,</span>
            <span class="s">&#39;standard_broadcasting&#39;</span><span class="p">:</span> <span class="n">standard_broadcasting</span><span class="p">,</span>
            <span class="s">&#39;__module__&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">)})</span>

        <span class="n">new_cls</span> <span class="o">=</span> <span class="n">mcls</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">_CompoundModel</span><span class="p">,),</span> <span class="n">members</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
            <span class="c"># Both models used in the operator were already instantiated models,</span>
            <span class="c"># not model *classes*.  As such it&#39;s not particularly useful to return</span>
            <span class="c"># the class itself, but to instead produce a new instance:</span>
            <span class="k">return</span> <span class="n">new_cls</span><span class="p">()</span>

        <span class="c"># Otherwise return the new uninstantiated class itself</span>
        <span class="k">return</span> <span class="n">new_cls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_backwards_compat</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c"># Override _handle_backwards_compat from _ModelMeta to be a no-op; it</span>
        <span class="c"># is not needed since compound models did not exist before version 1.0</span>
        <span class="c"># anyways.</span>

        <span class="c"># TODO: Remove this at the same time as removing</span>
        <span class="c"># _ModelMeta._handle_backwards_compat</span>
        <span class="k">return</span>

    <span class="c"># TODO: Perhaps, just perhaps, the post-order (or ???-order) ordering of</span>
    <span class="c"># leaf nodes is something the ExpressionTree class itself could just know</span>
    <span class="k">def</span> <span class="nf">_get_submodels</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="c"># Would make this a lazyproperty but those don&#39;t currently work with</span>
        <span class="c"># type objects</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_submodels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_submodels</span>

        <span class="n">submodels</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">traverse_postorder</span><span class="p">()</span>
                     <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isleaf</span><span class="p">]</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_submodels</span> <span class="o">=</span> <span class="n">submodels</span>
        <span class="k">return</span> <span class="n">submodels</span>

    <span class="k">def</span> <span class="nf">_init_param_descriptors</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This routine sets up the names for all the parameters on a compound</span>
<span class="sd">        model, including figuring out unique names for those parameters and</span>
<span class="sd">        also mapping them back to their associated parameters of the underlying</span>
<span class="sd">        submodels.</span>

<span class="sd">        Setting this all up is costly, and only necessary for compound models</span>
<span class="sd">        that a user will directly interact with.  For example when building an</span>
<span class="sd">        expression like::</span>

<span class="sd">            &gt;&gt;&gt; M = (Model1 + Model2) * Model3  # doctest: +SKIP</span>

<span class="sd">        the user will generally never interact directly with the temporary</span>
<span class="sd">        result of the subexpression ``(Model1 + Model2)``.  So there&#39;s no need</span>
<span class="sd">        to setup all the parameters for that temporary throwaway.  Only once</span>
<span class="sd">        the full expression is built and the user initializes or introspects</span>
<span class="sd">        ``M`` is it necessary to determine its full parameterization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Accessing cls.param_names will implicitly call _init_param_names if</span>
        <span class="c"># needed and thus also set up the _param_map; I&#39;m not crazy about that</span>
        <span class="c"># design but it stands for now</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">submodel_idx</span><span class="p">,</span> <span class="n">submodel_param</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_param_map</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
            <span class="n">submodel</span> <span class="o">=</span> <span class="n">cls</span><span class="p">[</span><span class="n">submodel_idx</span><span class="p">]</span>

            <span class="n">orig_param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="n">submodel_param</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orig_param</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="c"># This is just a pathological case that is only really needed</span>
                <span class="c"># to support the deprecated _CompositeModel--composite models</span>
                <span class="c"># claim to have some parameters, but don&#39;t actually implement</span>
                <span class="c"># the parameter descriptors, so we just make one up basically,</span>
                <span class="c"># with a default value of zero.  This value will just be thrown</span>
                <span class="c"># away, basically.</span>
                <span class="c"># TODO: Remove this special case once the legacy interfaces</span>
                <span class="c"># have been removed (basically this entire if statement--keep</span>
                <span class="c"># only the parts in the else: clause.</span>
                <span class="n">new_param</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">param_name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
                    <span class="c"># Take the parameter&#39;s default from the model&#39;s value for that</span>
                    <span class="c"># parameter</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="n">orig_param</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="n">orig_param</span><span class="o">.</span><span class="n">default</span>

                <span class="c"># Note: Parameter.copy() returns a new unbound Parameter, never</span>
                <span class="c"># a bound Parameter even if submodel is a Model instance (as</span>
                <span class="c"># opposed to a Model subclass)</span>
                <span class="n">new_param</span> <span class="o">=</span> <span class="n">orig_param</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">param_name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">new_param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_param_names</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This subroutine is solely for setting up the ``param_names`` attribute</span>
<span class="sd">        itself.</span>

<span class="sd">        See ``_init_param_descriptors`` for the full parameter setup.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Currently this skips over Model *instances* in the expression tree;</span>
        <span class="c"># basically these are treated as constants and do not add</span>
        <span class="c"># fittable/tunable parameters to the compound model.</span>
        <span class="c"># TODO: I&#39;m not 100% happy with this design, and maybe we need some</span>
        <span class="c"># interface for distinguishing fittable/settable parameters with</span>
        <span class="c"># *constant* parameters (which would be distinct from parameters with</span>
        <span class="c"># fixed constraints since they&#39;re permanently locked in place). But I&#39;m</span>
        <span class="c"># not sure if this is really the best way to treat the issue.</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">param_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Start counting the suffix indices to put on parameter names from the</span>
        <span class="c"># slice_offset.  Usually this will just be zero, but for compound</span>
        <span class="c"># models that were sliced from another compound model this may be &gt; 0</span>
        <span class="n">param_suffix</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_slice_offset</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="c"># Skip models that don&#39;t have parameters in the numbering</span>
                <span class="c"># TODO: Reevaluate this if it turns out to be confusing, though</span>
                <span class="c"># parameter-less models are not very common in practice (there</span>
                <span class="c"># are a few projections that don&#39;t take parameters)</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="c"># This is sort of heuristic, but we want to check that</span>
                <span class="c"># model.param_name *actually* returns a Parameter descriptor,</span>
                <span class="c"># and that the model isn&#39;t some inconsistent type that happens</span>
                <span class="c"># to have a param_names attribute but does not actually</span>
                <span class="c"># implement settable parameters.</span>
                <span class="c"># In the future we can probably remove this check, but this is</span>
                <span class="c"># here specifically to support the legacy compat</span>
                <span class="c"># _CompositeModel which can be considered a pathological case</span>
                <span class="c"># in the context of the new framework</span>
                <span class="c">#if not isinstance(getattr(model, param_name, None),</span>
                <span class="c">#                  Parameter):</span>
                <span class="c">#    break</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;{0}_{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">param_suffix</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">param_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_param_map</span> <span class="o">=</span> <span class="n">param_map</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_param_map_inverse</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_map</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_format_expression</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="c"># TODO: At some point might be useful to make a public version of this,</span>
        <span class="c"># albeit with more formatting options</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">format_expression</span><span class="p">(</span><span class="n">OPERATOR_PRECEDENCE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalize_index</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an index given to __getitem__ to either an integer, or</span>
<span class="sd">        a slice with integer start and stop values.</span>

<span class="sd">        If the length of the slice is exactly 1 this converts the index to a</span>
<span class="sd">        simple integer lookup.</span>

<span class="sd">        Negative integers are converted to positive integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_index_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s">&#39;Compound model {0} does not have a component named &#39;</span>
                    <span class="s">&#39;{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">check_for_negative_index</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span>
                <span class="k">if</span> <span class="n">new_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># If still &lt; 0 then this is an invalid index</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                            <span class="s">&quot;Model index {0} out of range.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>

            <span class="k">return</span> <span class="n">index</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">get_index_from_name</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="c"># In principle it could be but I can scarcely imagine a case</span>
                <span class="c"># where it would be useful.  If someone can think of one then</span>
                <span class="c"># we can enable it.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;Step not supported for compound model slicing.&quot;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span>
                    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">check_for_negative_index</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">check_for_negative_index</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">get_index_from_name</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">get_index_from_name</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

            <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">start</span>
            <span class="k">elif</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Empty slice of a compound model.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">submodel_names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s">&quot;Model index {0} out of range.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">check_for_negative_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s">&#39;Submodels can be indexed either by their integer order or &#39;</span>
            <span class="s">&#39;their name (got {0!r}).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_slice</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new model build from a sub-expression of the expression</span>
<span class="sd">        represented by this model.</span>

<span class="sd">        Right now this is highly inefficient, as it creates a new temporary</span>
<span class="sd">        model for each operator that appears in the sub-expression.  It would</span>
<span class="sd">        be better if this just built a new expression tree, and the new model</span>
<span class="sd">        instantiated directly from that tree.</span>

<span class="sd">        Once tree -&gt; model instantiation is possible this should be fixed to</span>
<span class="sd">        use that instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">members</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;_slice_offset&#39;</span><span class="p">:</span> <span class="n">cls</span><span class="o">.</span><span class="n">_slice_offset</span> <span class="o">+</span> <span class="n">start</span><span class="p">}</span>
        <span class="n">operators</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">oper</span><span class="p">,</span> <span class="n">_model_oper</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">additional_members</span><span class="o">=</span><span class="n">members</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">oper</span> <span class="ow">in</span> <span class="n">BINARY_OPERATORS</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_model_evaluate_getter</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
        <span class="n">n_inputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span>
        <span class="n">n_outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span>

        <span class="c"># There is currently an unfortunate inconsistency in some models, which</span>
        <span class="c"># requires them to be instantiated for their evaluate to work.  I think</span>
        <span class="c"># that needs to be reconsidered and fixed somehow, but in the meantime</span>
        <span class="c"># we need to check for that case</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">isinstancemethod</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Where previously model was a class, now make an instance</span>
                <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                    <span class="n">param_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">))</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">param_values</span><span class="p">)</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">param_values</span><span class="p">)),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                    <span class="n">param_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">param_values</span><span class="p">)</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">param_values</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evaluate</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span>
            <span class="k">if</span> <span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> \
                    <span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">islice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">))),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> \
                    <span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">islice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_params</span><span class="p">)))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_outputs</span><span class="p">)</span>


<span class="nd">@six.add_metaclass</span><span class="p">(</span><span class="n">_CompoundModelMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_CompoundModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">col_fit_deriv</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">_submodels</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_param_map_inverse</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param_map</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">_from_existing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">submodel_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">submodel_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">param_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fittable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">fittable</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c"># TODO: The way this works is highly inefficient--the inverse is created by</span>
    <span class="c"># making a new model for each operator in the compound model, which could</span>
    <span class="c"># potentially mean creating a large number of temporary throwaway model</span>
    <span class="c"># classes.  This can definitely be optimized in the future by implementing</span>
    <span class="c"># a way to construct a single model class from an existing tree</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_not_implemented</span><span class="p">(</span><span class="n">oper</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_raise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s">&quot;The inverse is not currently defined for compound &quot;</span>
                    <span class="s">&quot;models created using the {0} operator.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oper</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_raise</span>

        <span class="n">operators</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">oper</span><span class="p">,</span> <span class="n">_not_implemented</span><span class="p">(</span><span class="n">oper</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">oper</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;**&#39;</span><span class="p">))</span>
        <span class="n">operators</span><span class="p">[</span><span class="s">&#39;&amp;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span>
        <span class="c"># Reverse the order of compositions</span>
        <span class="n">operators</span><span class="p">[</span><span class="s">&#39;|&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">leaf_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># By indexing on self[] this will return an instance of the</span>
                <span class="c"># model, with all the appropriate parameters set, which is</span>
                <span class="c"># currently required to return an inverse</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">inverse</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s">&quot;All models in a composite model must have an inverse &quot;</span>
                    <span class="s">&quot;defined in order for the composite model to have an &quot;</span>
                    <span class="s">&quot;inverse.  {0!r} does not have an inverse.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>


        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">getter</span><span class="p">)</span>

    <span class="nd">@sharedmethod</span>
    <span class="k">def</span> <span class="nf">_get_submodels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_get_submodels</span><span class="p">()</span>


<div class="viewcode-block" id="custom_model"><a class="viewcode-back" href="../../../api/astropy.modeling.custom_model.html#astropy.modeling.custom_model">[docs]</a><span class="k">def</span> <span class="nf">custom_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a model from a user defined function. The inputs and parameters of</span>
<span class="sd">    the model will be inferred from the arguments of the function.</span>

<span class="sd">    This can be used either as a function or as a decorator.  See below for</span>
<span class="sd">    examples of both usages.</span>

<span class="sd">    .. note::</span>

<span class="sd">        All model parameters have to be defined as keyword arguments with</span>
<span class="sd">        default values in the model function.  Use `None` as a default argument</span>
<span class="sd">        value if you do not want to have a default value for that parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Function which defines the model.  It should take N positional</span>
<span class="sd">        arguments where ``N`` is dimensions of the model (the number of</span>
<span class="sd">        independent variable in the model), and any number of keyword arguments</span>
<span class="sd">        (the parameters).  It must return the value of the model (typically as</span>
<span class="sd">        an array, but can also be a scalar for scalar inputs).  This</span>
<span class="sd">        corresponds to the `~astropy.modeling.Model.evaluate` method.</span>
<span class="sd">    fit_deriv : function, optional</span>
<span class="sd">        Function which defines the Jacobian derivative of the model. I.e., the</span>
<span class="sd">        derivative with respect to the *parameters* of the model.  It should</span>
<span class="sd">        have the same argument signature as ``func``, but should return a</span>
<span class="sd">        sequence where each element of the sequence is the derivative</span>
<span class="sd">        with respect to the corresponding argument. This corresponds to the</span>
<span class="sd">        :meth:`~astropy.modeling.FittableModel.fit_deriv` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a sinusoidal model function as a custom 1D model::</span>

<span class="sd">        &gt;&gt;&gt; from astropy.modeling.models import custom_model</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; def sine_model(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return amplitude * np.sin(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; def sine_deriv(x, amplitude=1., frequency=1.):</span>
<span class="sd">        ...     return 2 * np.pi * amplitude * np.cos(2 * np.pi * frequency * x)</span>
<span class="sd">        &gt;&gt;&gt; SineModel = custom_model(sine_model, fit_deriv=sine_deriv)</span>

<span class="sd">    Create an instance of the custom model and evaluate it::</span>

<span class="sd">        &gt;&gt;&gt; model = SineModel()</span>
<span class="sd">        &gt;&gt;&gt; model(0.25)</span>
<span class="sd">        1.0</span>

<span class="sd">    This model instance can now be used like a usual astropy model.</span>

<span class="sd">    The next example demonstrates a 2D Moffat function model, and also</span>
<span class="sd">    demonstrates the support for docstrings (this example could also include</span>
<span class="sd">    a derivative, but it has been omitted for simplicity)::</span>

<span class="sd">        &gt;&gt;&gt; @custom_model</span>
<span class="sd">        ... def Moffat2D(x, y, amplitude=1.0, x_0=0.0, y_0=0.0, gamma=1.0,</span>
<span class="sd">        ...            alpha=1.0):</span>
<span class="sd">        ...     \&quot;\&quot;\&quot;Two dimensional Moffat function.\&quot;\&quot;\&quot;</span>
<span class="sd">        ...     rr_gg = ((x - x_0) ** 2 + (y - y_0) ** 2) / gamma ** 2</span>
<span class="sd">        ...     return amplitude * (1 + rr_gg) ** (-alpha)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; print(Moffat2D.__doc__)</span>
<span class="sd">        Two dimensional Moffat function.</span>
<span class="sd">        &gt;&gt;&gt; model = Moffat2D()</span>
<span class="sd">        &gt;&gt;&gt; model(1, 1)  # doctest: +FLOAT_CMP</span>
<span class="sd">        0.3333333333333333</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fit_deriv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;fit_deriv&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">_custom_model_wrapper</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_custom_model_wrapper</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="n">fit_deriv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s">&quot;{0} takes at most one positional argument (the callable/&quot;</span>
            <span class="s">&quot;function to be turned into a model.  When used as a decorator &quot;</span>
            <span class="s">&quot;it should be passed keyword arguments only (if &quot;</span>
            <span class="s">&quot;any).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">__name__</span><span class="p">))</span>

</div>
<span class="k">def</span> <span class="nf">_custom_model_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">fit_deriv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal implementation `custom_model`.</span>

<span class="sd">    When `custom_model` is called as a function its arguments are passed to</span>
<span class="sd">    this function, and the result of this function is returned.</span>

<span class="sd">    When `custom_model` is used as a decorator a partial evaluation of this</span>
<span class="sd">    function is returned by `custom_model`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s">&quot;func is not callable; it must be a function or other callable &quot;</span>
            <span class="s">&quot;object&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span>
            <span class="s">&quot;fit_deriv not callable; it must be a function or other &quot;</span>
            <span class="s">&quot;callable object&quot;</span><span class="p">)</span>

    <span class="n">model_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span>
    <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">param_values</span> <span class="o">=</span> <span class="n">argspec</span><span class="o">.</span><span class="n">defaults</span> <span class="ow">or</span> <span class="p">()</span>

    <span class="n">nparams</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_values</span><span class="p">)</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="n">nparams</span><span class="p">:]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">get_function_defaults</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">))</span> <span class="o">!=</span> <span class="n">nparams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ModelDefinitionError</span><span class="p">(</span><span class="s">&quot;derivative function should accept &quot;</span>
                                   <span class="s">&quot;same number of parameters as func.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nparams</span><span class="p">:</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="n">nparams</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span>

    <span class="c"># TODO: Maybe have a clever scheme for default output name?</span>
    <span class="k">if</span> <span class="n">input_names</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">param_names</span><span class="p">,</span> <span class="n">param_values</span><span class="p">))</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">find_current_module</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">modname</span> <span class="o">=</span> <span class="s">&#39;__main__&#39;</span>

    <span class="n">members</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;__module__&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">),</span>
        <span class="s">&#39;__doc__&#39;</span><span class="p">:</span> <span class="n">func</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span>
        <span class="s">&#39;inputs&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_names</span><span class="p">),</span>
        <span class="s">&#39;outputs&#39;</span><span class="p">:</span> <span class="n">output_names</span><span class="p">,</span>
        <span class="s">&#39;evaluate&#39;</span><span class="p">:</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">fit_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">members</span><span class="p">[</span><span class="s">&#39;fit_deriv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">fit_deriv</span><span class="p">)</span>

    <span class="n">members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="p">(</span><span class="n">FittableModel</span><span class="p">,),</span> <span class="n">members</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepare_inputs_single_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">broadcasts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

        <span class="c"># Ensure that array scalars are always upgrade to 1-D arrays for the</span>
        <span class="c"># sake of consistency with how parameters work.  They will be cast back</span>
        <span class="c"># to scalars at the end</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_shape</span><span class="p">:</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_broadcast</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">standard_broadcasting</span><span class="p">:</span>
                    <span class="n">broadcast</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">broadcast</span> <span class="o">=</span> <span class="n">input_shape</span>
            <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;Model input argument {0!r} of shape {1!r} cannot be &quot;</span>
                    <span class="s">&quot;broadcast with parameter {2!r} of shape &quot;</span>
                    <span class="s">&quot;{3!r}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">,</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="n">broadcast</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">):</span>
                <span class="n">max_broadcast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">)</span>

        <span class="n">broadcasts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_broadcast</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">&gt;</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">broadcasts</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&quot;For models with n_outputs &gt; n_inputs, the combination of &quot;</span>
                <span class="s">&quot;all inputs and parameters must broadcast to the same shape, &quot;</span>
                <span class="s">&quot;which will be used as the shape of all outputs.  In this &quot;</span>
                <span class="s">&quot;case some of the inputs had different shapes, so it is &quot;</span>
                <span class="s">&quot;ambiguous how to format outputs for this model.  Try using &quot;</span>
                <span class="s">&quot;inputs that are all the same size and shape.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Extend the broadcasts list to include shapes for all outputs</span>
            <span class="n">extra_outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span>
            <span class="n">broadcasts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">broadcasts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">extra_outputs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="n">broadcasts</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_prepare_outputs_single_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">):</span>
    <span class="n">broadcasts</span> <span class="o">=</span> <span class="n">format_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">broadcasts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">broadcast_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcast_shape</span><span class="p">:</span>
                <span class="c"># Shape is (), i.e. a scalar should be returned</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepare_inputs_model_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">reshaped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">max_param_shape</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
            <span class="c"># Use the shape of the input *excluding* the model axis</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">+</span>
                           <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check_broadcast</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">IncompatibleShapeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;Model input argument {0!r} of shape {1!r} cannot be &quot;</span>
                    <span class="s">&quot;broadcast with parameter {2!r} of shape &quot;</span>
                    <span class="s">&quot;{3!r}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">,</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">):</span>
                <span class="n">max_param_shape</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span>

        <span class="c"># We&#39;ve now determined that, excluding the model_set_axis, the</span>
        <span class="c"># input can broadcast with all the parameters</span>
        <span class="n">input_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">input_ndim</span><span class="p">:</span>
                <span class="c"># Just needs to prepend new axes to the input</span>
                <span class="n">n_new_axes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_axes</span> <span class="o">+</span> <span class="n">_input</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">input_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span>
                             <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span><span class="p">:])</span>
            <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">input_ndim</span><span class="p">:</span>
                <span class="n">n_new_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">input_ndim</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_new_axes</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_axes</span> <span class="o">+</span>
                             <span class="n">_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">_input</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_param_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">new_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">_input</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                                        <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">pivots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span>
        <span class="n">reshaped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reshaped</span><span class="p">,</span> <span class="p">(</span><span class="n">pivots</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_prepare_outputs_model_set</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">format_info</span><span class="p">):</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="n">format_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">pivots</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">:</span>
            <span class="n">outputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span>
                                       <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_input_shapes</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span> <span class="n">n_models</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span>
                           <span class="n">validate_broadcasting</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform basic validation of model inputs--that they are mutually</span>
<span class="sd">    broadcastable and that they have the minimum dimensions for the given</span>
<span class="sd">    model_set_axis.</span>

<span class="sd">    If validation succeeds, returns the total shape that will result from</span>
<span class="sd">    broadcasting the input arrays with each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check_model_set_axis</span> <span class="o">=</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">validate_broadcasting</span> <span class="ow">or</span> <span class="n">check_model_set_axis</span><span class="p">):</span>
        <span class="c"># Nothing else needed here</span>
        <span class="k">return</span>

    <span class="n">all_shapes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_input</span><span class="p">)</span>
        <span class="c"># Ensure that the input&#39;s model_set_axis matches the model&#39;s</span>
        <span class="c"># n_models</span>
        <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">and</span> <span class="n">check_model_set_axis</span><span class="p">:</span>
            <span class="c"># Note: Scalar inputs *only* get a pass on this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;For model_set_axis={0}, all inputs must be at &quot;</span>
                    <span class="s">&quot;least {1}-dimensional.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">input_shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;Input argument {0!r} does not have the correct &quot;</span>
                    <span class="s">&quot;dimensions in model_set_axis={1} for a model set with &quot;</span>
                    <span class="s">&quot;n_models={2}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">argnames</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">model_set_axis</span><span class="p">,</span>
                                           <span class="n">n_models</span><span class="p">))</span>
        <span class="n">all_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">validate_broadcasting</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">input_broadcast</span> <span class="o">=</span> <span class="n">check_broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">all_shapes</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">IncompatibleShapesError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">shape_a</span><span class="p">,</span> <span class="n">shape_a_idx</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">,</span> <span class="n">shape_b_idx</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
        <span class="n">arg_a</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">shape_a_idx</span><span class="p">]</span>
        <span class="n">arg_b</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[</span><span class="n">shape_b_idx</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&quot;Model input argument {0!r} of shape {1!r} cannot &quot;</span>
            <span class="s">&quot;be broadcast with input {2!r} of shape {3!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">arg_a</span><span class="p">,</span> <span class="n">shape_a</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">,</span> <span class="n">shape_b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">input_broadcast</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2015, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2. &nbsp;
    Last built 18 Feb 2015. <br/>
  </p>
</footer>
  </body>
</html>