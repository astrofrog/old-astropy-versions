<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Compound Models &mdash; Astropy v1.0</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/badge_only.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.0" href="../index.html" />
    <link rel="up" title="Models and Fitting (astropy.modeling)" href="index.html" />
    <link rel="next" title="Defining New Model Classes" href="new.html" />
    <link rel="prev" title="Fitting Models to Data" href="fitting.html" />

<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="../_static/copybutton.js"></script>


<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://astropy.readthedocs.org/en/latest/modeling/compound-models.html" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "astropy",
    version: "v1.0",
    language: "en",
    page: "modeling/compound-models",
    builder: "sphinx",
    theme: "bootstrap-astropy",
    docroot: "/docs/",
    source_suffix: ".rst",
    api_host: "https://readthedocs.org",
    commit: "b14c2e50123aafafd612a79ffb8ad69a0616f52f"
  }
  // Old variables
  var doc_version = "v1.0";
  var doc_slug = "astropy";
  var page_name = "modeling/compound-models";
  var html_theme = "bootstrap-astropy";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  // User Analytics Code
  _gaq.push(['user._setAccount', 'UA-30968842-1']);
  _gaq.push(['user._trackPageview']);
  // End User Analytics Code


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->

  </head>
  <body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="new.html" title="Defining New Model Classes">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="fitting.html" title="Fitting Models to Data">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="../index.html">Astropy v1.0</a>
	 &raquo;
      </li>
      <li><a href="index.html" accesskey="U">Models and Fitting (<tt class="docutils literal"><span class="pre">astropy.modeling</span></tt>)</a> &raquo;</li>
      
      <li>Compound Models</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="compound-models">
<span id="id1"></span><h1>Compound Models<a class="headerlink" href="#compound-models" title="Permalink to this headline">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.</span></p>
</div>
<p>As noted in the <a class="reference internal" href="index.html#compound-models-intro"><em>introduction to the modeling package</em></a>, it is now possible to create new models just by
combining existing models using the arithmetic operators <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>,
<tt class="docutils literal"><span class="pre">/</span></tt>, and <tt class="docutils literal"><span class="pre">**</span></tt>, as well as by model composition using <tt class="docutils literal"><span class="pre">|</span></tt> and
concatenation (explained below) with <tt class="docutils literal"><span class="pre">&amp;</span></tt>.</p>
<div class="section" id="some-terminology">
<h2>Some terminology<a class="headerlink" href="#some-terminology" title="Permalink to this headline">¶</a></h2>
<p>In discussing the compound model feature, it is useful to be clear about a
few terms where there have been points of confusion:</p>
<ul>
<li><p class="first">The term &#8220;model&#8221; can refer either to a model <em>class</em> or a model <em>instance</em>.</p>
<ul class="simple">
<li>All models in <a class="reference internal" href="index.html#module-astropy.modeling" title="astropy.modeling"><tt class="xref py py-obj docutils literal"><span class="pre">astropy.modeling</span></tt></a>, whether it represents some
<a class="reference internal" href="index.html#module-astropy.modeling.functional_models" title="astropy.modeling.functional_models"><tt class="xref py py-obj docutils literal"><span class="pre">function</span></tt></a>, a
<a class="reference internal" href="index.html#module-astropy.modeling.rotations" title="astropy.modeling.rotations"><tt class="xref py py-obj docutils literal"><span class="pre">rotation</span></tt></a>, etc., are represented in the
abstract by a model <em>class</em>&#8211;specifically a subclass of
<a class="reference internal" href="../api/astropy.modeling.Model.html#astropy.modeling.Model" title="astropy.modeling.Model"><tt class="xref py py-obj docutils literal"><span class="pre">Model</span></tt></a>&#8211;that encapsulates the routine for evaluating the
model, a list of its required parameters, and other metadata about the
model.</li>
<li>Per typical object-oriented parlance, a model <em>instance</em> is the object
created when when calling a model class with some arguments&#8211;in most cases
values for the model&#8217;s parameters.</li>
</ul>
<p>A model class, by itself, cannot be used to perform any computation because
most models, at least, have one or more parameters that must be specified
before the model can be evaluated on some input data. However, we can still
get some information about a model class from its representation.  For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Gaussian1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Gaussian1D</span>
<span class="go">&lt;class &#39;astropy.modeling.functional_models.Gaussian1D&#39;&gt;</span>
<span class="go">Name: Gaussian1D</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude&#39;, &#39;mean&#39;, &#39;stddev&#39;)</span>
</pre></div>
</div>
<p>We can then create a model <em>instance</em> by passing in values for the three
parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span> <span class="o">=</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span>  
<span class="go">&lt;Gaussian1D(amplitude=1.0, mean=0.0, stddev=0.2)&gt;</span>
</pre></div>
</div>
<p>We now have an <em>instance</em> of <a class="reference internal" href="../api/astropy.modeling.functional_models.Gaussian1D.html#astropy.modeling.functional_models.Gaussian1D" title="astropy.modeling.functional_models.Gaussian1D"><tt class="xref py py-obj docutils literal"><span class="pre">Gaussian1D</span></tt></a>
with all its parameters (and in principle other details like fit constraints)
filled in so that we can perform calculations with it as though it were a
function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>  
<span class="go">0.6065306597126334</span>
</pre></div>
</div>
<p>In many cases this document just refers to &#8220;models&#8221;, where the class/instance
distinction is either irrelevant or clear from context.  But a distinction
will be made where necessary.</p>
</li>
<li><p class="first">A <em>compound model</em> can be created by combining two or more existing models&#8211;
be they model <em>instances</em> or <em>classes</em>, and can be models that come with
Astropy, <a class="reference internal" href="new.html"><em>user defined models</em></a>, or other compound models&#8211;using
Python expressions consisting of one or more of the supported binary
operators.</p>
</li>
<li><p class="first">In some places the term <em>composite model</em> is used interchangeably with
<em>compound model</em>.  This can be seen in the cases of the now deprecated
<a class="reference internal" href="../api/astropy.modeling.SerialCompositeModel.html#astropy.modeling.SerialCompositeModel" title="astropy.modeling.SerialCompositeModel"><tt class="xref py py-obj docutils literal"><span class="pre">SerialCompositeModel</span></tt></a> and
<a class="reference internal" href="../api/astropy.modeling.SummedCompositeModel.html#astropy.modeling.SummedCompositeModel" title="astropy.modeling.SummedCompositeModel"><tt class="xref py py-obj docutils literal"><span class="pre">SummedCompositeModel</span></tt></a>.  However, this document uses the
term <em>composite model</em> to refer <em>only</em> to the case of a compound model
created from the functional composition of two or more models using the pipe
operator <tt class="docutils literal"><span class="pre">|</span></tt> as explained below.  This distinction is used consistently
within this document, but it may be helpful to understand the distinction.</p>
</li>
</ul>
</div>
<div class="section" id="creating-compound-models">
<h2>Creating compound models<a class="headerlink" href="#creating-compound-models" title="Permalink to this headline">¶</a></h2>
<p>As discussed in the <a class="reference internal" href="index.html#compound-models-intro"><em>introduction to compound models</em></a>, the only way, currently, to create compound models is
to combine existing single models and/or compound models using expressions in
Python with the binary operators <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>,
and <tt class="docutils literal"><span class="pre">&amp;</span></tt>, each of which is discussed in the following sections.  The operands
used in these expressions may be model <em>classes</em>, or model <em>instances</em>.  In
other words, any object for which either <tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">Model)</span></tt> or
<tt class="docutils literal"><span class="pre">issubclass(obj,</span> <span class="pre">Model)</span></tt> is <a class="reference external" href="http://docs.python.org/library/constants.html#True" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">True</span></tt></a>.</p>
<div class="section" id="compound-model-classes">
<span id="id2"></span><h3>Compound model classes<a class="headerlink" href="#compound-model-classes" title="Permalink to this headline">¶</a></h3>
<p>We start by demonstrating how new compound model <em>classes</em> can be created
by combining other classes.  This is more advanced usage, but it&#8217;s useful to
understand that this is what&#8217;s going on under the hood in the more basic usage
of <a class="reference internal" href="#compound-model-instances"><em>compound model instances</em></a>.</p>
<p>When all models involved in the expression are classes, the result of the
expression is, itself, a class (remember, classes in Python are themselves also
objects just like strings and integers or model instances):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">TwoGaussians</span> <span class="o">=</span> <span class="n">Gaussian1D</span> <span class="o">+</span> <span class="n">Gaussian1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling</span> <span class="kn">import</span> <span class="n">Model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">TwoGaussians</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">TwoGaussians</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When we inspect the variable <tt class="docutils literal"><span class="pre">TwoGaussians</span></tt> by printing its representation at
the command prompt we can get some more information about it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">TwoGaussians</span>
<span class="go">&lt;class &#39;__main__.CompoundModel...&#39;&gt;</span>
<span class="go">Name: CompoundModel...</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude_0&#39;, &#39;mean_0&#39;, &#39;stddev_0&#39;, &#39;amplitude_1&#39;, &#39;mean_1&#39;, &#39;stddev_1&#39;)</span>
<span class="go">Expression: [0] + [1]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;class &#39;astropy.modeling.functional_models.Gaussian1D&#39;&gt;</span>
<span class="go">    Name: Gaussian1D</span>
<span class="go">    Inputs: (&#39;x&#39;,)</span>
<span class="go">    Outputs: (&#39;y&#39;,)</span>
<span class="go">    Fittable parameters: (&#39;amplitude&#39;, &#39;mean&#39;, &#39;stddev&#39;)</span>

<span class="go">    [1]: &lt;class &#39;astropy.modeling.functional_models.Gaussian1D&#39;&gt;</span>
<span class="go">    Name: Gaussian1D</span>
<span class="go">    Inputs: (&#39;x&#39;,)</span>
<span class="go">    Outputs: (&#39;y&#39;,)</span>
<span class="go">    Fittable parameters: (&#39;amplitude&#39;, &#39;mean&#39;, &#39;stddev&#39;)</span>
</pre></div>
</div>
<p>There are a number of things to point out here:  This model class has six
fittable parameters.  How parameters are handled is discussed further in the
section on <a class="reference internal" href="#compound-model-parameters"><em>Parameters</em></a>.  We also see that there is a
listing of the <em>expression</em> that was used to create this compound model, which
in this case is summarized as <tt class="docutils literal"><span class="pre">[0]</span> <span class="pre">+</span> <span class="pre">[1]</span></tt>.  The <tt class="docutils literal"><span class="pre">[0]</span></tt> and <tt class="docutils literal"><span class="pre">[1]</span></tt> refer to
the first and second components of the model listed next (in this case both
components are the <a class="reference internal" href="../api/astropy.modeling.functional_models.Gaussian1D.html#astropy.modeling.functional_models.Gaussian1D" title="astropy.modeling.functional_models.Gaussian1D"><tt class="xref py py-obj docutils literal"><span class="pre">Gaussian1D</span></tt></a> class).</p>
<p>Each component of a compound model is a single, non-compound model.  This is
the case even when including an existing compound model in a new expression.
The existing compound model is not treated as a single model&#8211;instead the
expression represented by that compound model is extended.  An expression
involving two or more compound models results in a new expression that is the
concatenation of all involved models&#8217; expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FourGaussians</span> <span class="o">=</span> <span class="n">TwoGaussians</span> <span class="o">+</span> <span class="n">TwoGaussians</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FourGaussians</span>
<span class="go">&lt;class &#39;__main__.CompoundModel...&#39;&gt;</span>
<span class="go">Name: CompoundModel...</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude_0&#39;, &#39;mean_0&#39;, &#39;stddev_0&#39;, ..., &#39;amplitude_3&#39;, &#39;mean_3&#39;, &#39;stddev_3&#39;)</span>
<span class="go">Expression: [0] + [1] + [2] + [3]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;class &#39;astropy.modeling.functional_models.Gaussian1D&#39;&gt;</span>
<span class="go">    Name: Gaussian1D</span>
<span class="go">    Inputs: (&#39;x&#39;,)</span>
<span class="go">    Outputs: (&#39;y&#39;,)</span>
<span class="go">    Fittable parameters: (&#39;amplitude&#39;, &#39;mean&#39;, &#39;stddev&#39;)</span>
<span class="go">    ...</span>
<span class="go">    [3]: &lt;class &#39;astropy.modeling.functional_models.Gaussian1D&#39;&gt;</span>
<span class="go">    Name: Gaussian1D</span>
<span class="go">    Inputs: (&#39;x&#39;,)</span>
<span class="go">    Outputs: (&#39;y&#39;,)</span>
<span class="go">    Fittable parameters: (&#39;amplitude&#39;, &#39;mean&#39;, &#39;stddev&#39;)</span>
</pre></div>
</div>
<p>In a future version it may be possible to &#8220;freeze&#8221; a compound model, so that
from the user&#8217;s perspective it is treated as a single model.  However, as this
is the default behavior it is good to be aware of.</p>
</div>
<div class="section" id="model-names">
<h3>Model names<a class="headerlink" href="#model-names" title="Permalink to this headline">¶</a></h3>
<p>In the last two examples another notable feature of the generated compound
model classes is that the class name, as displayed when printing the class at
the command prompt, is not &#8220;TwoGaussians&#8221;, &#8220;FourGaussians&#8221;, etc.  Instead it is
a generated name consisting of &#8220;CompoundModel&#8221; followed by an essentially
arbitrary integer that is chosen simply so that every compound model has a
unique default name.  This is a limitation at present, due to the limitation
that it is not generally possible in Python when an object is created by an
expression for it to &#8220;know&#8221; the name of the variable it will be assigned to, if
any.  It may be possible in the future to work around this in limited cases,
but for now there are a couple workarounds for creating compound model classes
with friendlier names.  The first is to use the
<a class="reference internal" href="../api/astropy.modeling.Model.html#astropy.modeling.Model.rename" title="astropy.modeling.Model.rename"><tt class="xref py py-obj docutils literal"><span class="pre">Model.rename</span></tt></a> class method on the result of
the model expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">TwoGaussians</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gaussian1D</span> <span class="o">+</span> <span class="n">Gaussian1D</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;TwoGaussians&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TwoGaussians</span>
<span class="go">&lt;class &#39;__main__.TwoGaussians&#39;&gt;</span>
<span class="go">Name: TwoGaussians (CompoundModel...)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>This actually takes the generated compound model and creates a light subclass
of it with the desired name.  This does not impose any additional overhead.  An
alternative syntax, which is equivalent to what
<a class="reference internal" href="../api/astropy.modeling.Model.html#astropy.modeling.Model.rename" title="astropy.modeling.Model.rename"><tt class="xref py py-obj docutils literal"><span class="pre">rename</span></tt></a> is doing, is to directly use the model
expression as the base class of a new class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">TwoGaussians</span><span class="p">(</span><span class="n">Gaussian1D</span> <span class="o">+</span> <span class="n">Gaussian1D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;A superposition of two Gaussians.&quot;&quot;&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TwoGaussians</span>
<span class="go">&lt;class &#39;__main__.TwoGaussians&#39;&gt;</span>
<span class="go">Name: TwoGaussians (CompoundModel...)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Because the result of the expression <tt class="docutils literal"><span class="pre">Gaussian1D</span> <span class="pre">+</span> <span class="pre">Gaussian1D</span></tt> <em>is</em> a class,
it can be used directly in the standard class declaration syntax
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">ClassName(Base):</span></tt> as the base.  This syntax also has the advantage of
allowing a docstring to be assigned to the new class.  In future versions it
may be possible to customize other aspects of compound model classes in this
way.  Single model classes can also be given custom names by using
<a class="reference internal" href="../api/astropy.modeling.Model.html#astropy.modeling.Model.rename" title="astropy.modeling.Model.rename"><tt class="xref py py-obj docutils literal"><span class="pre">rename</span></tt></a>, and model instances can be given names as
well.  This can be used to good effect, for example as shown in the section on
<a class="reference internal" href="#compound-model-indexing"><em>Indexing and slicing</em></a>.</p>
</div>
<div class="section" id="compound-models-with-model-instances">
<span id="compound-model-instances"></span><h3>Compound models with model instances<a class="headerlink" href="#compound-models-with-model-instances" title="Permalink to this headline">¶</a></h3>
<p>So far we have seen how to create compound model <em>classes</em> from expressions
involving other model classes.  This is the most &#8220;generic&#8221; way to create new
models from existing models.  However, many may find it more useful most of the
time, especially when providing an initial guess to a fitter, to create a new
model from a combination of model <em>instances</em> with already defined parameter
values.  This can also be done and works mostly the same way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">both_gaussians</span> <span class="o">=</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">both_gaussians</span>  
<span class="go">&lt;CompoundModel...(amplitude_0=1.0, mean_0=0.0, stddev_0=0.2, amplitude_1=2.5, mean_1=0.5, stddev_1=0.1)&gt;</span>
</pre></div>
</div>
<p>Unlike when a model was created from model classes, this expression does not
directly return a new class; instead it creates a model instance that is ready
to be used for evaluation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">both_gaussians</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>  
<span class="go">0.6343031510582392</span>
</pre></div>
</div>
<p>This was found to be much more convenient and natural, in this case, than
returning a class.  It is worth understanding that the way this works under the
hood is to create the compound class, and then immediately instantiate it with
the already known parameter values.  We can see this by checking the type of
<tt class="docutils literal"><span class="pre">both_gaussians</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">both_gaussians</span><span class="p">)</span>  
<span class="go">&lt;class &#39;__main__.CompoundModel...&#39;&gt;</span>
<span class="go">Name: CompoundModel...</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude_0&#39;, &#39;mean_0&#39;, &#39;stddev_0&#39;, &#39;amplitude_1&#39;, &#39;mean_1&#39;, &#39;stddev_1&#39;)</span>
<span class="go">Expression: [0] + [1]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;Gaussian1D(amplitude=1.0, mean=0.0, stddev=0.2)&gt;</span>

<span class="go">    [1]: &lt;Gaussian1D(amplitude=2.5, mean=0.5, stddev=0.1)&gt;</span>
</pre></div>
</div>
<p>It is also possible, and sometimes useful, to make a compound model from a
combination of classes <em>and</em> instances in the same expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Linear1D</span><span class="p">,</span> <span class="n">Sine1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyModel</span> <span class="o">=</span> <span class="n">Linear1D</span> <span class="o">+</span> <span class="n">Sine1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyModel</span>
<span class="go">&lt;class &#39;__main__.CompoundModel...&#39;&gt;</span>
<span class="go">Name: CompoundModel...</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;slope_0&#39;, &#39;intercept_0&#39;, &#39;amplitude_1&#39;, &#39;frequency_1&#39;)</span>
<span class="go">Expression: [0] + [1]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;class &#39;astropy.modeling.functional_models.Linear1D&#39;&gt;</span>
<span class="go">    Name: Linear1D</span>
<span class="go">    Inputs: (&#39;x&#39;,)</span>
<span class="go">    Outputs: (&#39;y&#39;,)</span>
<span class="go">    Fittable parameters: (&#39;slope&#39;, &#39;intercept&#39;)</span>

<span class="go">    [1]: &lt;Sine1D(amplitude=1.0, frequency=1.0)&gt;</span>
</pre></div>
</div>
<p>In this case the result is always a class.  However (and this is not
immediately obvious by the representation) the difference is that the
<tt class="docutils literal"><span class="pre">amplitude</span></tt> and <tt class="docutils literal"><span class="pre">frequency</span></tt> parameters for the
<a class="reference internal" href="../api/astropy.modeling.functional_models.Sine1D.html#astropy.modeling.functional_models.Sine1D" title="astropy.modeling.functional_models.Sine1D"><tt class="xref py py-obj docutils literal"><span class="pre">Sine1D</span></tt></a> part of the model are
&#8220;baked into&#8221; the class as default values for those parameters.  So it is
possible to instantiate one of these models by specifying just the <tt class="docutils literal"><span class="pre">slope</span></tt>
and <tt class="docutils literal"><span class="pre">intercept</span></tt> parameters for the
<a class="reference internal" href="../api/astropy.modeling.functional_models.Linear1D.html#astropy.modeling.functional_models.Linear1D" title="astropy.modeling.functional_models.Linear1D"><tt class="xref py py-obj docutils literal"><span class="pre">Linear1D</span></tt></a> part of the model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_model</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_model</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>  <span class="c"># doctest +FLOAT_CMP</span>
<span class="go">1.25</span>
</pre></div>
</div>
<p>This does not prevent the other parameters from being overridden, however:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_model</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">(</span><span class="n">slope_0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">intercept_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">frequency_1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_model</span><span class="p">(</span><span class="mf">0.125</span><span class="p">)</span>  <span class="c"># doctest +FLOAT_CMP</span>
<span class="go">1.125</span>
</pre></div>
</div>
<p>In fact, this is currently the only way to use a <a class="reference internal" href="index.html#module-astropy.modeling.polynomial" title="astropy.modeling.polynomial"><tt class="xref py py-obj docutils literal"><span class="pre">polynomial</span></tt></a> model in a compound model, because the design of
the polynomial models is currently such that they must be instantiated in order
to specify their polynomial degree.  Because the polynomials are already
designed so that their coefficients all default to zero, this &#8220;limitation&#8221;
should not have any practical drawbacks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is currently a caveat in the example of combining model classes and
instances, which is that the parameter values of model <em>instances</em> are only
treated as defaults if the expression is written in such a way that all
model instances are to the right of all model classes.  This limitation
will be lifted in a later version&#8211;in particular, Python 3 offers a lot
more flexibility with respect to how function arguments are handled.</p>
</div>
</div>
</div>
<div class="section" id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="arithmetic-operators">
<h3>Arithmetic operators<a class="headerlink" href="#arithmetic-operators" title="Permalink to this headline">¶</a></h3>
<p>Compound models can be created from expressions that include any
number of the arithmetic operators <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, and
<tt class="docutils literal"><span class="pre">**</span></tt>, which have the same meanings as they do for other numeric
objects in Python.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the case of division <tt class="docutils literal"><span class="pre">/</span></tt> always means floating point division&#8211;integer
division and the <tt class="docutils literal"><span class="pre">//</span></tt> operator is not supported for models).</p>
</div>
<p>As demonstrated in previous examples, for models that have a single output
the result of evaluating a model like <tt class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></tt> is to evaluate <tt class="docutils literal"><span class="pre">A</span></tt> and
<tt class="docutils literal"><span class="pre">B</span></tt> separately on the given input, and then return the sum of the outputs of
<tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>.  This requires that <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> take the same number of
inputs and both have a single output.</p>
<p>It is also possible to use arithmetic operators between models with multiple
outputs.  Again, the number of inputs must be the same between the models, as
must be the number of outputs.  In this case the operator is applied to the
operators element-wise, similarly to how arithmetic operators work on two Numpy
arrays.</p>
</div>
<div class="section" id="model-composition">
<span id="compound-model-composition"></span><h3>Model composition<a class="headerlink" href="#model-composition" title="Permalink to this headline">¶</a></h3>
<p>The sixth binary operator that can be used to create compound models is the
composition operator, also known as the &#8220;pipe&#8221; operator <tt class="docutils literal"><span class="pre">|</span></tt> (not to be
confused with the boolean &#8220;or&#8221; operator that this implements for Python numeric
objects).  A model created with the composition operator like <tt class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">F</span> <span class="pre">|</span> <span class="pre">G</span></tt>,
when evaluated, is equivalent to evaluating <img class="math" src="../_images/math/362ee9bb6bcbdec076a5ba8530fe4e6a71bb3a8c.png" alt="g \circ f = g(f(x))"/>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fact that the <tt class="docutils literal"><span class="pre">|</span></tt> operator has the opposite sense as the functional
composition operator <img class="math" src="../_images/math/e3e1b8a98590631e4c5dc9df782ebe2cd9822722.png" alt="\circ"/> is sometimes a point of confusion.
This is in part because there is no operator symbol supported in Python
that corresponds well to this.  The <tt class="docutils literal"><span class="pre">|</span></tt> operator should instead be read
like the <a class="reference external" href="http://en.wikipedia.org/wiki/Pipeline_%28Unix%29">pipe operator</a> of UNIX shell syntax:
It chains together models by piping the output of the left-hand operand to
the input of the right-hand operand, forming a &#8220;pipeline&#8221; of models, or
transformations.</p>
</div>
<p>This has different requirements on the inputs/outputs of its operands than do
the arithmetic operators.  For composition all that is required is that the
left-hand model has the same number of outputs as the right-hand model has
inputs.</p>
<p>For simple functional models this is exactly the same as functional
composition, except for the aforementioned caveat about ordering.  For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Redshift</span><span class="p">,</span> <span class="n">Gaussian1D</span>

<span class="k">class</span> <span class="nc">RedshiftedGaussian</span><span class="p">(</span><span class="n">Redshift</span> <span class="o">|</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates a Gaussian with optional redshift applied to the input.&quot;&quot;&quot;</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">g0</span> <span class="o">=</span> <span class="n">RedshiftedGaussian</span><span class="p">(</span><span class="n">z_0</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g0</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&#39;g--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;$z=0$&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">RedshiftedGaussian</span><span class="p">(</span><span class="n">z_0</span><span class="o">=</span><span class="n">z</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">OrRd</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
             <span class="n">label</span><span class="o">=</span><span class="s">&#39;$z={0}$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Energy&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Flux&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../modeling/compound-models-1.py">Source code</a>, <a class="reference external" href="../modeling/compound-models-1.png">png</a>, <a class="reference external" href="../modeling/compound-models-1.hires.png">hires.png</a>, <a class="reference external" href="../modeling/compound-models-1.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/compound-models-1.png" src="../_images/compound-models-1.png" />
</div>
<p>When working with models with multiple inputs and outputs the same idea
applies.  If each input is thought of as a coordinate axis, then this defines a
pipeline of transformations for the coordinates on each axis (though it does
not necessarily guarantee that these transformations are separable).  For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Rotation2D</span><span class="p">,</span> <span class="n">Gaussian2D</span>

<span class="k">class</span> <span class="nc">RotatedGaussian</span><span class="p">(</span><span class="n">Rotation2D</span> <span class="o">|</span> <span class="n">Gaussian2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;A Gaussian2D composed with a coordinate rotation.&quot;&quot;&quot;</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">))</span>

<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">90</span><span class="p">)):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">RotatedGaussian</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Rotated $ {0}^\circ $&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../modeling/compound-models-2.py">Source code</a>, <a class="reference external" href="../modeling/compound-models-2.png">png</a>, <a class="reference external" href="../modeling/compound-models-2.hires.png">hires.png</a>, <a class="reference external" href="../modeling/compound-models-2.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/compound-models-2.png" src="../_images/compound-models-2.png" />
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The above example is a bit contrived in that
<a class="reference internal" href="../api/astropy.modeling.functional_models.Gaussian2D.html#astropy.modeling.functional_models.Gaussian2D" title="astropy.modeling.functional_models.Gaussian2D"><tt class="xref py py-obj docutils literal"><span class="pre">Gaussian2D</span></tt></a> already supports an
optional rotation parameter.  However, this demonstrates how coordinate
rotation could be added to arbitrary models.</p>
</div>
<p>Normally it is not possible to compose, say, a model with two outputs and a
function of only one input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Rotation2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rotation2D</span> <span class="o">|</span> <span class="n">Gaussian1D</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ModelDefinitionError</span>: <span class="n">Unsupported operands for |: Rotation2D (n_inputs=2, n_outputs=2) and Gaussian1D (n_inputs=1, n_outputs=1); n_outputs for the left-hand model must match n_inputs for the right-hand model.</span>
</pre></div>
</div>
<p>However, as we will see in the next section,
<a class="reference internal" href="#compound-model-concatenation"><em>Model concatenation</em></a>, provides a means of creating models
that apply transformations to only some of the outputs from a model,
especially when used in concert with <a class="reference internal" href="#compound-model-mappings"><em>mappings</em></a>.</p>
</div>
<div class="section" id="model-concatenation">
<span id="compound-model-concatenation"></span><h3>Model concatenation<a class="headerlink" href="#model-concatenation" title="Permalink to this headline">¶</a></h3>
<p>The concatenation operator <tt class="docutils literal"><span class="pre">&amp;</span></tt>, sometimes also referred to as a &#8220;join&#8221;,
combines two models into a single, fully separable transformation.  That is, it
makes a new model that takes the inputs to the left-hand model, concatenated
with the inputs to the right-hand model, and returns a tuple consisting of the
two models&#8217; outputs concatenated together, without mixing in any way.  In other
words, it simply evaluates the two models in parallel&#8211;it can be thought of as
something like a tuple of models.  For example, given two coordinate axes, we
can scale each coordinate by a different factor by concatenating two
<a class="reference internal" href="../api/astropy.modeling.functional_models.Scale.html#astropy.modeling.functional_models.Scale" title="astropy.modeling.functional_models.Scale"><tt class="xref py py-obj docutils literal"><span class="pre">Scale</span></tt></a> models:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Scale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separate_scales</span> <span class="o">=</span> <span class="n">Scale</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Scale</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="mf">3.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">separate_scales</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">(1.2, 6.8)</span>
</pre></div>
</div>
<p>We can also combine concatenation with composition to build chains of
transformations that use both &#8220;1D&#8221; and &#8220;2D&#8221; models on two (or more) coordinate
axes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">scale_and_rotate</span> <span class="o">=</span> <span class="p">((</span><span class="n">Scale</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Scale</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="mf">3.4</span><span class="p">))</span> <span class="o">|</span>
<span class="gp">... </span>                    <span class="n">Rotation2D</span><span class="p">(</span><span class="mi">90</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale_and_rotate</span><span class="o">.</span><span class="n">n_inputs</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale_and_rotate</span><span class="o">.</span><span class="n">n_outputs</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale_and_rotate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">(-6.8, 1.2)</span>
</pre></div>
</div>
<p>This is of course equivalent to an
<a class="reference internal" href="../api/astropy.modeling.projections.AffineTransformation2D.html#astropy.modeling.projections.AffineTransformation2D" title="astropy.modeling.projections.AffineTransformation2D"><tt class="xref py py-obj docutils literal"><span class="pre">AffineTransformation2D</span></tt></a> with the appropriate
transformation matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">allclose</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">AffineTransformation2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">AffineTransformation2D</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># May be small numerical differences due to different implementations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">allclose</span><span class="p">(</span><span class="n">scale_and_rotate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">affine</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="indexing-and-slicing">
<span id="compound-model-indexing"></span><h2>Indexing and slicing<a class="headerlink" href="#indexing-and-slicing" title="Permalink to this headline">¶</a></h2>
<p>As seen in some of the previous examples in this document, when creating a
compound model each component of the model is assigned an integer index
starting from zero.  These indices are assigned simply by reading the
expression that defined the model, from left to right, regardless of the order
of operations.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Const1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Const1D</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">Const1D</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Const1D</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">&lt;class &#39;__main__.CompoundModel...&#39;&gt;</span>
<span class="go">Name: CompoundModel...</span>
<span class="gp">...</span>
<span class="go">Expression: [0] + [1] * [2]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;class &#39;__main__.A&#39;&gt;</span>
<span class="go">    Name: A (Const1D)</span>
<span class="go">    ...</span>

<span class="go">    [1]: &lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">    Name: B (Const1D)</span>
<span class="go">    ...</span>

<span class="go">    [2]: &lt;class &#39;__main__.C&#39;&gt;</span>
<span class="go">    Name: C (Const1D)</span>
<span class="go">    ...</span>
</pre></div>
</div>
<p>In this example the expression is evaluated <tt class="docutils literal"><span class="pre">(B</span> <span class="pre">*</span> <span class="pre">C)</span> <span class="pre">+</span> <span class="pre">A</span></tt>&#8211;that is, the
multiplication is evaluated before the addition per usual arithmetic rules.
However, the components of this model are simply read off left to right from
the expression <tt class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">C</span></tt>, with <tt class="docutils literal"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">2</span></tt>.  If we
had instead defined <tt class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">A</span></tt> then the indices would be reversed
(though the expression is mathematically equivalent).  This convention is
chosen for simplicity&#8211;given the list of components it is not necessary to
jump around when mentally mapping them to the expression.</p>
<p>We can pull out each individual component of the compound model <tt class="docutils literal"><span class="pre">M</span></tt> by using
indexing notation on it.  Following from the above example, <tt class="docutils literal"><span class="pre">M[1]</span></tt> should
return the model <tt class="docutils literal"><span class="pre">B</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">Name: B (Const1D)</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude&#39;,)</span>
</pre></div>
</div>
<p>We can also take a <em>slice</em> of the compound model.  This returns a new compound
model that evaluates the <em>subexpression</em> involving the models selected by the
slice.  This follows the same semantics as slicing a <a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">list</span></tt></a> or array in Python.
The start point is inclusive and the end point is exclusive.  So a slice like
<tt class="docutils literal"><span class="pre">M[1:3]</span></tt> (or just <tt class="docutils literal"><span class="pre">M[1:]</span></tt>) selects models <tt class="docutils literal"><span class="pre">B</span></tt> and <tt class="docutils literal"><span class="pre">C</span></tt> (and all
<em>operators</em> between them).  So the resulting model evaluates just the
subexpression <tt class="docutils literal"><span class="pre">B</span> <span class="pre">*</span> <span class="pre">C</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">&lt;class &#39;astropy.modeling.utils.CompoundModel...&#39;&gt;</span>
<span class="go">Name: CompoundModel...</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude_1&#39;, &#39;amplitude_2&#39;)</span>
<span class="go">Expression: [0] * [1]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">    Name: B (Const1D)</span>
<span class="go">    ...</span>

<span class="go">    [1]: &lt;class &#39;__main__.C&#39;&gt;</span>
<span class="go">    Name: C (Const1D)</span>
<span class="go">    ...</span>
</pre></div>
</div>
<p>The new compound model for the subexpression can be instantiated and evaluated
like any other:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:](</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;CompoundModel...(amplitude_1=2.0, amplitude_2=3.0)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">6.0</span>
</pre></div>
</div>
<p>Although the model <tt class="docutils literal"><span class="pre">M</span></tt> was composed entirely of <tt class="docutils literal"><span class="pre">Const1D</span></tt> models in this
example, it was useful to give each component a unique name (<tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">B</span></tt>,
<tt class="docutils literal"><span class="pre">C</span></tt>) in order to differentiate between them.  This can also be used for
indexing and slicing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">]</span>
<span class="go">&lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">Name: B (Const1D)</span>
<span class="go">Inputs: (&#39;x&#39;,)</span>
<span class="go">Outputs: (&#39;y&#39;,)</span>
<span class="go">Fittable parameters: (&#39;amplitude&#39;,)</span>
</pre></div>
</div>
<p>In this case <tt class="docutils literal"><span class="pre">M['B']</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">M[1]</span></tt>.  But by using the name we do
not have to worry about what index that component is in (this becomes
especially useful when combining multiple compound models).  A current
limitation, however, is that each component of a compound model must have a
unique name&#8211;if some components have duplicate names then they can only be
accessed by their integer index.  This may improve in a future release.</p>
<p>Slicing also works with names.  When using names the start and end points are
<em>both inclusive</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">:</span><span class="s">&#39;C&#39;</span><span class="p">]</span>
<span class="go">&lt;class &#39;astropy.modeling.utils.CompoundModel...&#39;&gt;</span>
<span class="gp">...</span>
<span class="go">Expression: [0] * [1]</span>
<span class="go">Components:</span>
<span class="go">    [0]: &lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">    Name: B (Const1D)</span>
<span class="go">    ...</span>

<span class="go">    [1]: &lt;class &#39;__main__.C&#39;&gt;</span>
<span class="go">    Name: C (Const1D)</span>
<span class="go">    ...</span>
</pre></div>
</div>
<p>So in this case <tt class="docutils literal"><span class="pre">M['B':'C']</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">M[1:3]</span></tt>.</p>
<p>All of the above applies equally well to compound models composed of model
instances.  Individual model instances can be given a name by passing in the
<tt class="docutils literal"><span class="pre">name=</span></tt> argument when instantiating them.  These names are used in the same was
as class names were in the class-based examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Const1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Const1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Const1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
</pre></div>
</div>
<p>Because this model is composed entirely of constants it doesn&#8217;t matter what
input we pass in, so 0 is used without loss of generality:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">:](</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># b * c</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">:</span><span class="s">&#39;B&#39;</span><span class="p">](</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># a + b</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">:</span><span class="s">&#39;C&#39;</span><span class="p">](</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># b * c, again</span>
<span class="go">6.0</span>
</pre></div>
</div>
</div>
<div class="section" id="parameters">
<span id="compound-model-parameters"></span><h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>A question that frequently comes up when first encountering compound models is
how exactly all the parameters are dealt with.  By now we&#8217;ve seen a few
examples that give some hints, but a more detailed explanation is in order.
This is also one of the biggest areas for possible improvements&#8211;the current
behavior is meant to be practical, but is not ideal.  (Some possible
improvements include being able to rename parameters, and providing a means of
narrowing down the number of parameters in a compound model.)</p>
<p>As explained in the general documentation for model <a class="reference internal" href="parameters.html#modeling-parameters"><em>parameters</em></a>, every model has an attribute called
<a class="reference internal" href="../api/astropy.modeling.Model.html#astropy.modeling.Model.param_names" title="astropy.modeling.Model.param_names"><tt class="xref py py-obj docutils literal"><span class="pre">param_names</span></tt></a> that contains a tuple of all the model&#8217;s
adjustable parameters.  These names are given in a canonical order that also
corresponds to the order in which the parameters should be specified when
instantiating the model.</p>
<p>The simple scheme used currently for naming parameters in a compound model is
this:  The <tt class="docutils literal"><span class="pre">param_names</span></tt> from each component model are concatenated with each
other in order from left to right as explained in the section on
<a class="reference internal" href="#compound-model-indexing"><em>Indexing and slicing</em></a>.  However, each parameter name is appended with
<tt class="docutils literal"><span class="pre">_&lt;#&gt;</span></tt>, where <tt class="docutils literal"><span class="pre">&lt;#&gt;</span></tt> is the index of the component model that parameter
belongs to.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Gaussian1D</span><span class="o">.</span><span class="n">param_names</span>
<span class="go">(&#39;amplitude&#39;, &#39;mean&#39;, &#39;stddev&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Gaussian1D</span> <span class="o">+</span> <span class="n">Gaussian1D</span><span class="p">)</span><span class="o">.</span><span class="n">param_names</span>
<span class="go">(&#39;amplitude_0&#39;, &#39;mean_0&#39;, &#39;stddev_0&#39;, &#39;amplitude_1&#39;, &#39;mean_1&#39;, &#39;stddev_1&#39;)</span>
</pre></div>
</div>
<p>For consistency&#8217;s sake, this scheme is followed even if not all of the
components have overlapping parameter names:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Redshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Redshift</span> <span class="o">|</span> <span class="p">(</span><span class="n">Gaussian1D</span> <span class="o">+</span> <span class="n">Gaussian1D</span><span class="p">))</span><span class="o">.</span><span class="n">param_names</span>
<span class="go">(&#39;z_0&#39;, &#39;amplitude_1&#39;, &#39;mean_1&#39;, &#39;stddev_1&#39;, &#39;amplitude_2&#39;, &#39;mean_2&#39;,</span>
<span class="go">&#39;stddev_2&#39;)</span>
</pre></div>
</div>
<p>On some level a scheme like this is necessary in order for the compound model
to maintain some consistency with other models with respect to the interface to
its parameters.  However, if one gets lost it is also possible to take
advantage of <a class="reference internal" href="#compound-model-indexing"><em>indexing</em></a> to make things easier.
When returning a single component from a compound model the parameters
associated with that component are accessible through their original names, but
are still tied back to the compound model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">amplitude_0</span>
<span class="go">Parameter(&#39;amplitude_0&#39;, value=1.0)</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">amplitude</span>
<span class="go">Parameter(&#39;amplitude&#39;, value=1.0)</span>
</pre></div>
</div>
<p>You can think of these both as different &#8220;views&#8221; of the same parameter.
Updating one updates the other:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">amplitude_0</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">amplitude</span>
<span class="go">Parameter(&#39;amplitude&#39;, value=42.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">amplitude_0</span>
<span class="go">Parameter(&#39;amplitude_0&#39;, value=99.0)</span>
</pre></div>
</div>
<p>Note, however, that the original
<a class="reference internal" href="../api/astropy.modeling.functional_models.Gaussian1D.html#astropy.modeling.functional_models.Gaussian1D" title="astropy.modeling.functional_models.Gaussian1D"><tt class="xref py py-obj docutils literal"><span class="pre">Gaussian1D</span></tt></a> instance <tt class="docutils literal"><span class="pre">a</span></tt> has not been
updated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">amplitude</span>
<span class="go">Parameter(&#39;amplitude&#39;, value=1.0)</span>
</pre></div>
</div>
<p>This is because currently, when a compound model is created, copies are made of
the original models.</p>
</div>
<div class="section" id="advanced-mappings">
<span id="compound-model-mappings"></span><h2>Advanced mappings<a class="headerlink" href="#advanced-mappings" title="Permalink to this headline">¶</a></h2>
<p>We have seen in some previous examples how models can be chained together to
form a &#8220;pipeline&#8221; of transformations by using model <a class="reference internal" href="#compound-model-composition"><em>composition</em></a> and <a class="reference internal" href="#compound-model-concatenation"><em>concatenation</em></a>.  To aid the creation of more complex chains of
transformations (for example for a WCS transformation) a new class of
&#8220;<a class="reference internal" href="index.html#module-astropy.modeling.mappings" title="astropy.modeling.mappings"><tt class="xref py py-obj docutils literal"><span class="pre">mapping</span></tt></a>&#8221; models is provided.</p>
<p>Mapping models do not (currently) take any parameters, nor do they perform any
numeric operation.  They are for use solely with the <a class="reference internal" href="#compound-model-concatenation"><em>concatenation</em></a> (<tt class="docutils literal"><span class="pre">&amp;</span></tt>) and <a class="reference internal" href="#compound-model-composition"><em>composition</em></a> (<tt class="docutils literal"><span class="pre">|</span></tt>) operators, and can be used to control how
the inputs and outputs of models are ordered, and how outputs from one model
are mapped to inputs of another model in a composition.</p>
<p>Currently there are only two mapping models:
<a class="reference internal" href="../api/astropy.modeling.mappings.Identity.html#astropy.modeling.mappings.Identity" title="astropy.modeling.mappings.Identity"><tt class="xref py py-obj docutils literal"><span class="pre">Identity</span></tt></a>, and (the somewhat generically named)
<a class="reference internal" href="../api/astropy.modeling.mappings.Mapping.html#astropy.modeling.mappings.Mapping" title="astropy.modeling.mappings.Mapping"><tt class="xref py py-obj docutils literal"><span class="pre">Mapping</span></tt></a>.</p>
<p>The <a class="reference internal" href="../api/astropy.modeling.mappings.Identity.html#astropy.modeling.mappings.Identity" title="astropy.modeling.mappings.Identity"><tt class="xref py py-obj docutils literal"><span class="pre">Identity</span></tt></a> mapping simply passes one or more
inputs through, unchanged.  It must be instantiated with an integer specifying
the number of inputs/outputs it accepts.  This can be used to trivially expand
the &#8220;dimensionality&#8221; of a model in terms of the number of inputs it accepts.
In the section on <a class="reference internal" href="#compound-model-concatenation"><em>concatenation</em></a> we saw
an example like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">Scale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Scale</span><span class="p">(</span><span class="mf">3.4</span><span class="p">))</span> <span class="o">|</span> <span class="n">Rotation2D</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
</pre></div>
</div>
<p>where two coordinate inputs are scaled individually and then rotated into each
other.  However, say we wanted to scale only one of those coordinates.  It
would be fine to simply use <tt class="docutils literal"><span class="pre">Scale(1)</span></tt> for one them, or any other model that
is effectively a no-op.  But that also adds unnecessary computational overhead,
so we might as well simply specify that that coordinate is not to be scaled or
transformed in any way.  This is a good use case for
<a class="reference internal" href="../api/astropy.modeling.mappings.Identity.html#astropy.modeling.mappings.Identity" title="astropy.modeling.mappings.Identity"><tt class="xref py py-obj docutils literal"><span class="pre">Identity</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Identity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Scale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="go">(1.2, 2.0)</span>
</pre></div>
</div>
<p>This scales the first input, and passes the second one through unchanged.  We
can use this to build up more complicated steps in a many-axis WCS
transformation.  If for example we had 3 axes and only wanted to scale the
first one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Scale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Identity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">(1.2, 2.0, 3.0)</span>
</pre></div>
</div>
<p>(Naturally, the last example could also be written out <tt class="docutils literal"><span class="pre">Scale(1.2)</span> <span class="pre">&amp;</span>
<span class="pre">Identity(1)</span> <span class="pre">&amp;</span> <span class="pre">Identity(1)</span></tt>.)</p>
<p>The <a class="reference internal" href="../api/astropy.modeling.mappings.Mapping.html#astropy.modeling.mappings.Mapping" title="astropy.modeling.mappings.Mapping"><tt class="xref py py-obj docutils literal"><span class="pre">Mapping</span></tt></a> model is similar in that it does not
modify any of its inputs.  However, it is more general in that it allows inputs
to be duplicated, reordered, or even dropped outright.  It is instantiated with
a single argument: a <a class="reference external" href="http://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">tuple</span></tt></a>, the number of items of which correspond to the
number of outputs the <a class="reference internal" href="../api/astropy.modeling.mappings.Mapping.html#astropy.modeling.mappings.Mapping" title="astropy.modeling.mappings.Mapping"><tt class="xref py py-obj docutils literal"><span class="pre">Mapping</span></tt></a> should produce.  A
1-tuple means that whatever inputs come in to the
<a class="reference internal" href="../api/astropy.modeling.mappings.Mapping.html#astropy.modeling.mappings.Mapping" title="astropy.modeling.mappings.Mapping"><tt class="xref py py-obj docutils literal"><span class="pre">Mapping</span></tt></a>, only one will be output.  And so on for
2-tuple or higher (though the length of the tuple cannot be greater than the
number of inputs&#8211;it will not pull values out of thin air).  The elements of
this mapping are integers corresponding to the indices of the inputs.  For
example, a mapping of <tt class="docutils literal"><span class="pre">Mapping((0,))</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">Identity(1)</span></tt>&#8211;it
simply takes the first (0-th) input and returns it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Likewise <tt class="docutils literal"><span class="pre">Mapping((0,</span> <span class="pre">1))</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">Identity(2)</span></tt>, and so on.
However, <a class="reference internal" href="../api/astropy.modeling.mappings.Mapping.html#astropy.modeling.mappings.Mapping" title="astropy.modeling.mappings.Mapping"><tt class="xref py py-obj docutils literal"><span class="pre">Mapping</span></tt></a> also allows outputs to be
reordered arbitrarily:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="go">(2.0, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="go">(2.0, 1.0, 3.0)</span>
</pre></div>
</div>
<p>Outputs may also be dropped:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="go">(1.0, 3.0)</span>
</pre></div>
</div>
<p>Or duplicated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">(1.0, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="go">(1.0, 2.0, 2.0, 3.0)</span>
</pre></div>
</div>
<p>A complicated example that performs multiple transformations, some separable,
some not, on three coordinate axes might look something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Polynomial1D</span> <span class="k">as</span> <span class="n">Poly1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.modeling.models</span> <span class="kn">import</span> <span class="n">Polynomial2D</span> <span class="k">as</span> <span class="n">Poly2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="p">((</span><span class="n">Poly1D</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c3</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Identity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Poly1D</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span>
<span class="gp">... </span>     <span class="n">Mapping</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span>
<span class="gp">... </span>     <span class="p">(</span><span class="n">Poly2D</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">c0_0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c1_1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c2_2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Gaussian1D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  
<span class="go">(41617.0, 0.7548396019890073)</span>
</pre></div>
</div>
<p>This expression takes three inputs: <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/>, <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/>, and <img class="math" src="../_images/math/84d7271dd9e78c1e05d6c3c6ecb60309ef7dfc73.png" alt="z"/>.  It
first takes <img class="math" src="../_images/math/78aca8c1bc318200880f18c1ad4fece8614f5602.png" alt="x \rightarrow x^3 + 1"/> and <img class="math" src="../_images/math/c50b08cb230985af5739f375cb4420d1aeb74576.png" alt="z \rightarrow z^2"/>.
Then it remaps the axes so that <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> and <img class="math" src="../_images/math/84d7271dd9e78c1e05d6c3c6ecb60309ef7dfc73.png" alt="z"/> are passed in to the
<a class="reference internal" href="../api/astropy.modeling.polynomial.Polynomial2D.html#astropy.modeling.polynomial.Polynomial2D" title="astropy.modeling.polynomial.Polynomial2D"><tt class="xref py py-obj docutils literal"><span class="pre">Polynomial2D</span></tt></a> to evaluate
<img class="math" src="../_images/math/fdae12fe56d6d16a1b0bc97e27fd56eee5d642c6.png" alt="2x^2z^2 + xz + 1"/>, while simultaneously evaluating a Gaussian on
<img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/>.  The end result is a reduction down to two coordinates.  You can
confirm for yourself that the result is correct.</p>
<p>This opens up the possibility of essentially arbitrarily complex transformation
graphs.  Currently the tools do not exist to make it easy to navigate and
reason about highly complex compound models that use these mappings, but that
is a possible enhancement for future versions.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Compound Models</a><ul>
<li><a class="reference internal" href="#some-terminology">Some terminology</a></li>
<li><a class="reference internal" href="#creating-compound-models">Creating compound models</a><ul>
<li><a class="reference internal" href="#compound-model-classes">Compound model classes</a></li>
<li><a class="reference internal" href="#model-names">Model names</a></li>
<li><a class="reference internal" href="#compound-models-with-model-instances">Compound models with model instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operators">Operators</a><ul>
<li><a class="reference internal" href="#arithmetic-operators">Arithmetic operators</a></li>
<li><a class="reference internal" href="#model-composition">Model composition</a></li>
<li><a class="reference internal" href="#model-concatenation">Model concatenation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indexing-and-slicing">Indexing and slicing</a></li>
<li><a class="reference internal" href="#parameters">Parameters</a></li>
<li><a class="reference internal" href="#advanced-mappings">Advanced mappings</a></li>
</ul>
</li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="http://github.com/astropy/astropy/tree/v1.0.x/docs/modeling/compound-models.rst">Edit This Page on Github</a> &nbsp;
    <a href="../_sources/modeling/compound-models.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2015, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2. &nbsp;
    Last built 18 Feb 2015. <br/>
  </p>
</footer>
  </body>
</html>